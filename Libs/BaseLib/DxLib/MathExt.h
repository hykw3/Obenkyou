/*!
@file MathExt.h
@brief 行列、クオータニオン、カラーなどの計算クラス<br />
XNAMATH のラッピングクラス群
@copyright Copyright (c) 2017 WiZ Tamura Hiroki,Yamanoi Yasushi.
*/

#pragma once

#include "stdafx.h"

namespace basecross{

	struct Matrix4X4;
	//--------------------------------------------------------------------------------------
	///	Plane（平面）構造体
	//--------------------------------------------------------------------------------------
	struct Plane : public XMFLOAT4 {
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		*/
		//--------------------------------------------------------------------------------------
		Plane() :XMFLOAT4() {}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	v4	XMFLOAT4構造体
		*/
		//--------------------------------------------------------------------------------------
		Plane(const XMFLOAT4& v4) :XMFLOAT4() {
			x = v4.x;
			y = v4.y;
			z = v4.z;
			w = v4.w;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コピーコンストラクタ
		@param[in]	other	コピー元Plane
		*/
		//--------------------------------------------------------------------------------------
		Plane(const Plane& other) :XMFLOAT4() {
			x = other.x;
			y = other.y;
			z = other.z;
			w = other.w;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	other	コピー元XMVECTOR
		*/
		//--------------------------------------------------------------------------------------
		Plane(const XMVECTOR& other) :XMFLOAT4() {
			XMVECTOR temp = other;
			XMStoreFloat4(this, temp);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	Point	面上に存在する点
		@param[in]	Normal	法線
		*/
		//--------------------------------------------------------------------------------------
		Plane(const Vector3& Point, const Vector3& Normal) {
			*this = (Plane)XMPlaneFromPointNormal(XMVECTOR(Point), XMVECTOR(Normal));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	Point1	面上に存在する点1
		@param[in]	Point2	面上に存在する点2
		@param[in]	Point3	面上に存在する点3
		*/
		//--------------------------------------------------------------------------------------
		Plane(const Vector3& Point1, const Vector3& Point2, const Vector3& Point3) {
			*this = (Plane)XMPlaneFromPoints(XMVECTOR(Point1), XMVECTOR(Point2), XMVECTOR(Point3));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	XMVECTORへのキャスト（thisをキャストして返す）
		@return	XMVECTOR型の値
		*/
		//--------------------------------------------------------------------------------------
		operator XMVECTOR() const {
			XMFLOAT4 temp = *this;
			XMVECTOR Vec = XMLoadFloat4(&temp);
			return Vec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	メンバ変数への直接代入
		@param[in]	xx	x値
		@param[in]	yy	y値
		@param[in]	zz	z値
		@param[in]	ww	w値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Set(float xx, float yy, float zz, float ww) {
			x = xx;
			y = yy;
			z = zz;
			w = ww;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	0初期化（すべてを0にする）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Zero() {
			x = 0;
			y = 0;
			z = 0;
			w = 0;
		}
		//--------------------------------------------------------------------------------------
		//多重定義
		//--------------------------------------------------------------------------------------
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元
		@return	*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Plane& operator=(const Plane& other) {
			//自己代入の抑制
			if (this != &other) {
				x = other.x;
				y = other.y;
				z = other.z;
				w = other.w;
			}
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元(XMVECTOR型)
		@return	*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Plane& operator=(const XMVECTOR& other) {
			XMVECTOR temp = other;
			XMStoreFloat4(this, temp);
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisとother（Vector4）の内積を返す
		@param[in]	other	相手のベクトル
		@return	内積。平面と同次座標の関係を判定するときに役立つ。<br />
		たとえば、この関数を使用してある座標が特定の平面上に存在するか、<br />
		または座標が平面のどちら側に存在するかなどを判定できる。
		*/
		//--------------------------------------------------------------------------------------
		float Dot(const Vector4& other) const{
			return ((Vector4)XMPlaneDot(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisとother（Vector3）の内積を返す
		@param[in]	other	相手のベクトル
		@return	内積。あるポイントから平面までの符号付き距離を求めるのに便利である
		*/
		//--------------------------------------------------------------------------------------
		float DotCoord(const Vector3& other)const {
			return  ((Vector4)XMPlaneDotCoord(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	平面の法線ベクトルととother（Vector3）の内積を返す
		@param[in]	other	比べるベクトル
		@return	内積。平面の法線ベクトルと別の法線ベクトルとの角度を算出するときに役立つ。
		*/
		//--------------------------------------------------------------------------------------
		float DotNormal(const Vector3& other)const {
			return ((Vector4)XMPlaneDotNormal(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisと相手の平面が同じかどうかを調べる
		@param[in]	other	相手のPlane
		@return	同じならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Equal(const Plane& other)const {
			return XMPlaneEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	点と法線から平面を作成して、thisに設定する
		@param[in]	Point	平面上の点
		@param[in]	Normal	法線
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void FromPointNormal(const Vector3& Point, const Vector3& Normal) {
			*this = (Plane)XMPlaneFromPointNormal(XMVECTOR(Point), XMVECTOR(Normal));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	３点から平面を作成して、thisに設定する
		@param[in]	Point1	頂点1
		@param[in]	Point2	頂点2
		@param[in]	Point3	頂点3
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void FromPoints(const Vector3& Point1, const Vector3& Point2, const Vector3& Point3) {
			*this = (Plane)XMPlaneFromPoints(XMVECTOR(Point1), XMVECTOR(Point2), XMVECTOR(Point3));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisと２つの頂点が作成する直線の交差する頂点を返す<br />
		平面と直線が平行の場合は、戻る各値はQNaN（非数） になるので、<br />
		Vector3::IsNaN()などでチェックする
		@param[in]	LinePoint1	頂点1
		@param[in]	LinePoint2	頂点2
		@return	thisと交差する３Ｄベクトル
		*/
		//--------------------------------------------------------------------------------------
		Vector3 IntersectLine(const Vector3& LinePoint1, const Vector3& LinePoint2)const {
			return (Vector3)XMPlaneIntersectLine(XMVECTOR(*this),
				XMVECTOR(LinePoint1), XMVECTOR(LinePoint2));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisともう一つの面が交差する2つの頂点を計算する<br />
		2つの平面が平行の場合は、戻る各値はQNaN（非数） になるので、<br />
		Vector3::IsNaN()などでチェックする
		@param[out]	RetLinePoint1	返される頂点1
		@param[out]	RetLinePoint2	返される頂点2
		@param[in]	other	thisと比べられるもう一つの面
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void IntersectPlane(Vector3& RetLinePoint1, Vector3& RetLinePoint2,
			const Plane& other)const {
			XMVECTOR Temp1, Temp2;
			XMPlaneIntersectPlane(&Temp1, &Temp2, XMVECTOR(*this), XMVECTOR(other));
			RetLinePoint1 = (Vector3)Temp1;
			RetLinePoint2 = (Vector3)Temp2;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの要素のいずれかが正または負の無限大かどうかを調べる
		@return	正または負の無限大ならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsInfinite()const {
			return XMPlaneIsInfinite(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの要素のいずれかが NaNかどうかを調べる
		@return	NaNならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsNaN()const {
			return XMPlaneIsNaN(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisともう一つの平面がほぼ等しいかどうか調べる
		@param[in]	other	thisと比べられるもう一つの面
		@param[in]	Epsilon	各要素の許容範囲
		@return	ほぼ等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool NearEqual(const Plane& other, const Vector4& Epsilon)const {
			return XMPlaneNearEqual(XMVECTOR(*this), XMVECTOR(other), Epsilon);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisを正規化する(＊thisに結果を設定する)
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Normalize() {
			*this = (Plane)XMPlaneNormalize(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisをx,y,zの係数が単位の法線ベクトルを形成するように<br />
		平面の係数を予測(＊thisに結果を設定する)
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void NormalizeEst() {
			*this = (Plane)XMPlaneNormalizeEst(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisと相手の平面が等しくないかどうかを調べる
		@param[in]	other	相手のPlane
		@return	等しくないならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool NotEqual(const Plane& other)const {
			return XMPlaneNotEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisをmでトランスフォームする(＊thisに結果を設定する)
		@param[in]	m	トランスフォームする行列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Transform(const XMMATRIX& m) {
			*this = (Plane)XMPlaneTransform(XMVECTOR(*this), m);
		}
		//　XMPlaneTransformStream関数は、ラッピング関数は用意しない
		//　理由：パラメータに配列を渡す必要があり、ラッピングによって、最適化が損なわれる
	};


	//--------------------------------------------------------------------------------------
	///	r、g、b、aの色を定義する構造体
	//--------------------------------------------------------------------------------------
	struct Color4 : public XMFLOAT4 {
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		*/
		//--------------------------------------------------------------------------------------
		Color4() :XMFLOAT4() {
			x = 0;
			y = 0;
			z = 0;
			w = 0;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	v4	XMFLOAT4型
		*/
		//--------------------------------------------------------------------------------------
		Color4(const XMFLOAT4& v4) :XMFLOAT4(v4) {
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	other	コピー元
		*/
		//--------------------------------------------------------------------------------------
		Color4(const XMVECTOR& other) :XMFLOAT4() {
			XMVECTOR temp = other;
			XMStoreFloat4(this, temp);
		}

		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	other	コピー元
		*/
		//--------------------------------------------------------------------------------------
		Color4(const XMVECTORF32& other) :XMFLOAT4() {
			XMVECTOR temp = other;
			XMStoreFloat4(this, temp);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	x	X要素
		@param[in]	y	Y要素
		@param[in]	z	Z要素
		@param[in]	w	W要素
		*/
		//--------------------------------------------------------------------------------------
		Color4(float x, float y, float z, float w) :
			XMFLOAT4(x, y, z, w) {
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コピーコンストラクタ
		@param[in]	other	コピー元
		*/
		//--------------------------------------------------------------------------------------
		Color4(const Color4& other) :XMFLOAT4() {
			x = other.x;
			y = other.y;
			z = other.z;
			w = other.w;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	XMVECTORへのキャスト（thisをキャストして返す）
		@return	XMVECTOR型の値
		*/
		//--------------------------------------------------------------------------------------
		operator XMVECTOR() const {
			XMFLOAT4 temp = *this;
			XMVECTOR Vec = XMLoadFloat4(&temp);
			return Vec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	要素のセット
		@param[in]	xx	X要素
		@param[in]	yy	Y要素
		@param[in]	zz	Z要素
		@param[in]	ww	W要素
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Set(float xx, float yy, float zz, float ww) {
			x = xx;
			y = yy;
			z = zz;
			w = ww;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	0から255で設定
		@param[in]	x	X要素(0から255)
		@param[in]	y	Y要素(0から255)
		@param[in]	z	Z要素(0から255)
		@param[in]	w	W要素(0から255)
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetUint8(UINT8 ux, UINT8 uy, UINT8 uz, UINT8 uw) {
			x = (float)ux / 255.0f;
			y = (float)uy / 255.0f;
			z = (float)uz / 255.0f;
			w = (float)uw / 255.0f;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	要素をすべて0にセット
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Zero() {
			x = 0;
			y = 0;
			z = 0;
			w = 0;
		}
		//	多重定義
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Color4& operator=(const Color4& other) {
			//自己代入の抑制
			if (this != &other) {
				x = other.x;
				y = other.y;
				z = other.z;
				w = other.w;
			}
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Color4& operator=(const XMVECTOR& other) {
			XMVECTOR temp = other;
			XMStoreFloat4(this, temp);
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Color4& operator=(const XMVECTORF32& other) {
			XMVECTOR temp = other;
			XMStoreFloat4(this, temp);
			return *this;
		}

		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加加算
		@param[in]	other	追加する相手
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Color4& operator+=(const Color4& other) {
			x += other.x;
			y += other.y;
			z += other.z;
			w += other.w;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加減算
		@param[in]	other	減算する相手
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Color4& operator-=(const Color4& other) {
			x -= other.x;
			y -= other.y;
			z -= other.z;
			w -= other.w;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加乗算
		@param[in]	val	乗算する値（各要素共通）
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Color4& operator*=(float val) {
			x *= val;
			y *= val;
			z *= val;
			w *= val;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加除算
		@param[in]	val	除算する値（各要素共通）
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Color4& operator/=(float val) {
			if (val == 0.0f) {
				//0除算
				throw BaseException(
					L"0除算です",
					L"if(val == 0.0f)",
					L"Vector4::operator/=()"
					);
			}
			x /= val;
			y /= val;
			z /= val;
			w /= val;
			return *this;
		}
		//単項演算子
		//--------------------------------------------------------------------------------------
		/*!
		@brief	単項プラス
		@return	演算後のColor4
		*/
		//--------------------------------------------------------------------------------------
		Color4 operator+ () const {
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	単項マイナス
		@return	演算後のColor4
		*/
		//--------------------------------------------------------------------------------------
		Color4 operator- () const {
			Color4 ret = *this;
			ret *= -1.0f;
			return ret;
		}
		//演算
		//--------------------------------------------------------------------------------------
		/*!
		@brief	加算
		@param[in]	other	加算する相手
		@return	演算後のColor4
		*/
		//--------------------------------------------------------------------------------------
		Color4 operator+(const Color4& other)const {
			Color4 ret = *this;
			ret += other;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	減算
		@param[in]	other	減算する相手
		@return	演算後のColor4
		*/
		//--------------------------------------------------------------------------------------
		Color4 operator-(const Color4& other)const {
			Color4 ret = *this;
			ret -= other;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	乗算
		@param[in]	val	乗算する値（各要素共通）
		@return	演算後のColor4
		*/
		//--------------------------------------------------------------------------------------
		Color4 operator*(float val)const {
			Color4 ret = *this;
			ret *= val;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	除算
		@param[in]	val	除算する値（各要素共通）
		@return	演算後のColor4
		*/
		//--------------------------------------------------------------------------------------
		Color4 operator/(float val)const {
			if (val == 0.0f) {
				//0除算
				throw BaseException(
					L"0除算です",
					L"if(val == 0.0f)",
					L"Color4::operator/()"
					);
			}
			Color4 ret = *this;
			ret /= val;
			return ret;
		}
		//個別アクセス
		//--------------------------------------------------------------------------------------
		/*!
		@brief	R（赤）要素を得る
		@return	赤要素
		*/
		//--------------------------------------------------------------------------------------
		float GetR() const {
			return x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	R（赤）要素を設定する
		@param[in]	r	設定値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetR(float r) {
			x = r;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	G（緑）要素を得る
		@return	緑要素
		*/
		//--------------------------------------------------------------------------------------
		float GetG() const {
			return y;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	G（緑）要素を設定する
		@param[in]	g	設定値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetG(float g) {
			y = g;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	B（青）要素を得る
		@return	青要素
		*/
		//--------------------------------------------------------------------------------------
		float GetB() const {
			return z;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	B（青）要素を設定する
		@param[in]	b	設定値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetB(float b) {
			z = b;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	A（アルファ）要素を得る
		@return	アルファ要素
		*/
		//--------------------------------------------------------------------------------------
		float GetA() const {
			return w;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	A（アルファ）要素を設定する
		@param[in]	a	設定値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetA(float a) {
			w = a;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	要素すべてを設定する
		@param[in]	r	赤設定値
		@param[in]	g	緑設定値
		@param[in]	b	青設定値
		@param[in]	a	アルファ設定値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetRGBA(float r, float g, float b, float a) {
			x = r;
			y = g;
			z = b;
			w = a;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのカラーと等しいかどうかを検証する
		@param[in]	other	相手
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Equal(const Color4& other)const {
			return XMColorEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのカラーと等しいかどうか（==演算）
		@param[in]	other	相手
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator==(const Color4& other)const {
			return Equal(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのカラーと等しくないかどうか
		@param[in]	other	相手
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool NotEqual(const Color4& other)const {
			return XMColorNotEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのカラーと等しくないかどうか（!=演算）
		@param[in]	other	相手
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator!=(const Color4& other)const {
			return NotEqual(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのカラーより大きいかどうかを検証する
		@param[in]	other	相手
		@return	大きければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Greater(const Color4& other)const {
			return XMColorGreater(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのカラーより大きいかどうか（>演算）
		@param[in]	other	相手
		@return	大きければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator>(const Color4& other)const {
			return Greater(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのカラー以上かどうかを検証する
		@param[in]	other	相手
		@return	以上であればtrue
		*/
		//--------------------------------------------------------------------------------------
		bool GreaterOrEqual(const Color4& other)const {
			return XMColorGreaterOrEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのカラー以上かどうかを検証する（>=演算）
		@param[in]	other	相手
		@return	以上であればtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator>=(const Color4& other)const {
			return GreaterOrEqual(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのカラー以下かどうかを検証する
		@param[in]	other	相手
		@return	以下であればtrue
		*/
		//--------------------------------------------------------------------------------------
		bool LessOrEqual(const Color4& other)const {
			return XMColorLessOrEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのカラー以下かどうかを検証する（<=演算）
		@param[in]	other	相手
		@return	以下であればtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator<=(const Color4& other)const {
			return LessOrEqual(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのカラーより小さいかどうかを検証する
		@param[in]	other	相手
		@return	より小さければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Less(const Color4& other)const {
			return XMColorLess(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのカラーより小さいかどうかを検証する（<演算）
		@param[in]	other	相手
		@return	より小さければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator<(const Color4& other)const {
			return Less(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisのカラーのいずれかの成分が正または負の無限大かどうかをテストする
		@return	thisのカラーのいずれかの成分が正または負の無限大ならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsInfinite()const {
			return XMColorIsInfinite(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisのカラーのいずれかの成分がNaNかどうかをテストする
		@return	thisのカラーのいずれかの成分がNaNならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsNaN()const {
			return XMColorIsNaN(XMVECTOR(*this));
		}
		//操作
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisのカラーを0.0から1.0の範囲に調整しthisに設定する<br />
		範囲外の要素は0.0か1.0に設定される
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void AdjustRange() {
			if (this->x <= 0) {
				this->x = 0;
			}
			if (this->y <= 0) {
				this->y = 0;
			}
			if (this->z <= 0) {
				this->z = 0;
			}
			if (this->w <= 0) {
				this->w = 0;
			}
			if (this->x >= 1.0f) {
				this->x = 1.0f;
			}
			if (this->y >= 1.0f) {
				this->y = 1.0f;
			}
			if (this->z >= 1.0f) {
				this->z = 1.0f;
			}
			if (this->w >= 1.0f) {
				this->w = 1.0f;
			}
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisのカラーのコントラストを調節し、thisに設定する<br />
		カラーは0.0から1.0の範囲に調整され、計算される
		@param[in]	Contrast	コントラスト範囲
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void AdjustContrast(float Contrast) {
			AdjustRange();
			*this = (Color4)XMColorAdjustContrast(XMVECTOR(*this), Contrast);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	カラーの彩度を調節しthisに設定する<br />
		カラーは0.0から1.0の範囲に調整され、計算される<br />
		彩度値が0の場合はグレースケール、1.0の場合はもとの色になる
		@param[in]	Saturation	彩度値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void AdjustSaturation(float Saturation) {
			AdjustRange();
			*this = (Color4)XMColorAdjustSaturation(XMVECTOR(*this), Saturation);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisにもう一つのカラーの対応する成分を乗算してブレンドしたものをthisに設定する
		@param[in]	other	カラー
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Modulate(const Color4& other) {
			AdjustRange();
			*this = (Color4)XMColorModulate(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisのカラーの負の RGB カラー値を求めthisに設定する<br />
		カラーは0.0から1.0の範囲に調整され、計算される
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Negative() {
			AdjustRange();
			*this = (Color4)XMColorNegative(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisのカラーをグレーに設定する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void GrayColor() {
			*this = Color4(0.5f, 0.5f, 0.5f, 1.0f);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisのカラーを白に設定する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void WhiteColor() {
			*this = Color4(1.0f, 1.0f, 1.0f, 1.0f);
		}
	};

	//--------------------------------------------------------------------------------------
	///	クオータニオン構造体
	//--------------------------------------------------------------------------------------
	struct Quaternion : public XMFLOAT4 {
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		*/
		//--------------------------------------------------------------------------------------
		Quaternion() :XMFLOAT4() {
			Identity();
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	v4	XMFLOAT4値
		*/
		//--------------------------------------------------------------------------------------
		Quaternion(const XMFLOAT4& v4) :XMFLOAT4(v4) {
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	other	XMVECTOR値
		*/
		//--------------------------------------------------------------------------------------
		Quaternion(const XMVECTOR& other) :XMFLOAT4() {
			XMVECTOR temp = other;
			XMStoreFloat4(this, temp);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	x	x値
		@param[in]	y	y値
		@param[in]	z	z値
		@param[in]	w	w値
		*/
		//--------------------------------------------------------------------------------------
		Quaternion(float x, float y, float z, float w) :
			XMFLOAT4(x, y, z, w) {
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コピーコンストラクタ
		@param[in]	other	コピー元
		*/
		//--------------------------------------------------------------------------------------
		Quaternion(const Quaternion& other) :XMFLOAT4() {
			x = other.x;
			y = other.y;
			z = other.z;
			w = other.w;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ（回転スカラから作成）
		@param[in]	Pitch	X軸回転
		@param[in]	Yaw	Y軸回転
		@param[in]	Roll	Z軸回転
		*/
		//--------------------------------------------------------------------------------------
		Quaternion(float Pitch, float Yaw, float Roll) :XMFLOAT4() {
			RotationRollPitchYaw(Pitch, Yaw, Roll);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ（回転軸と角度から作成）
		@param[in]	Vec	回転軸
		@param[in]	Angle	回転値
		*/
		//--------------------------------------------------------------------------------------
		Quaternion(const Vector3& Vec, float Angle) :XMFLOAT4() {
			RotationAxis(Vec, Angle);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ（回転行列から作成）
		@param[in]	m	回転行列
		*/
		//--------------------------------------------------------------------------------------
		Quaternion(const XMMATRIX& m) :XMFLOAT4() {
			RotationMatrix(m);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ（回転行列から作成）
		@param[in]	m	回転行列
		*/
		//--------------------------------------------------------------------------------------
		inline Quaternion(const Matrix4X4& m);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	XMVECTORへのキャスト（thisをキャストして返す）
		@return	XMVECTOR型の値
		*/
		//--------------------------------------------------------------------------------------
		operator XMVECTOR() const {
			XMFLOAT4 temp = *this;
			XMVECTOR Vec = XMLoadFloat4(&temp);
			return Vec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	要素のセット
		@param[in]	xx	X要素
		@param[in]	yy	Y要素
		@param[in]	zz	Z要素
		@param[in]	ww	W要素
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Set(float xx, float yy, float zz, float ww) {
			x = xx;
			y = yy;
			z = zz;
			w = ww;
		}
		//--------------------------------------------------------------------------------------
		//	多重定義
		//--------------------------------------------------------------------------------------
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元
		@return	Quaternion
		*/
		//--------------------------------------------------------------------------------------
		Quaternion& operator=(const Quaternion& other) {
			//自己代入の抑制
			if (this != &other) {
				x = other.x;
				y = other.y;
				z = other.z;
				w = other.w;
			}
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元(XMVECTOR型)
		@return	Quaternion
		*/
		//--------------------------------------------------------------------------------------
		Quaternion& operator=(const XMVECTOR& other) {
			XMVECTOR temp = other;
			XMStoreFloat4(this, temp);
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisへの追加乗算(回転を追加できる)
		@param[in]	other	追加回転する値
		@return	Quaternion
		*/
		//--------------------------------------------------------------------------------------
		Quaternion& operator*=(const Quaternion& other) {
			*this = (Quaternion)XMQuaternionMultiply(XMVECTOR(*this), XMVECTOR(other));
			return *this;
		}
		//演算
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisとの追加乗算(回転を追加できる)
		@param[in]	other	追加回転する値
		@return	Quaternion
		*/
		//--------------------------------------------------------------------------------------
		Quaternion operator*(const Quaternion& other)const {
			Quaternion temp(*this);
			temp *= other;
			return temp;
		}
		//比較
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのクオータニオンと等しいかどうかを検証する
		@param[in]	other	比較するクオータニオン
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Equal(const Quaternion& other)const {
			return XMQuaternionEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのクオータニオンと等しいかどうかを検証する
		@param[in]	other	比較するクオータニオン
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator==(const Quaternion& other)const {
			return Equal(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのクオータニオンと等しくないかどうかを検証する
		@param[in]	other	比較するクオータニオン
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool NotEqual(const Quaternion& other)const {
			return XMQuaternionNotEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのクオータニオンと等しくないかどうかを検証する
		@param[in]	other	比較するクオータニオン
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator!=(const Quaternion& other)const {
			return NotEqual(other);
		}
		//検証
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisが単位クオータニオン (0, 0, 0, 1)かどうかを検証する
		@return	単位クオータニオン (0, 0, 0, 1)ならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsIdentity() const {
			return XMQuaternionIsIdentity(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの値のいずれかが正か負の無限大かどうかを検証する
		@return	値のいずれかが正か負の無限大ならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsInfinite() const {
			return XMQuaternionIsInfinite(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	値のいずれかがNaNかどうかを検証する
		@return	値のいずれかがNaNならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsNaN() const {
			return XMQuaternionIsNaN(XMVECTOR(*this));
		}
		//操作
		//--------------------------------------------------------------------------------------
		/*!
		@brief	回転ベクトルを追加回転しthisに設定する
		@param[in]	other	追加回転する回転ベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void AddRotation(const Vector3& other) {
			Quaternion Span;
			Span.RotationRollPitchYawFromVector(other);
			*this = (Quaternion)XMQuaternionMultiply(XMVECTOR(*this), XMVECTOR(Span));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	クオータニオンから回転ベクトルを返す
		@return	回転ベクトル
		*/
		//--------------------------------------------------------------------------------------
		inline Vector3 GetRotation()const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	三角形の1つ目のクオータニオンthisに、<br/>
		指定されたクオータニオンを使用して、重心座標のポイントを＊thisに設定する
		@param[in]	Q1	三角形の2つ目のクオータニオン
		@param[in]	Q2	三角形の3つ目のクオータニオン
		@param[in]	f	加重係数
		@param[in]	g	加重係数
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void BaryCentric(const Quaternion& Q1, const Quaternion& Q2, float f, float g) {
			*this = (Quaternion)XMQuaternionBaryCentric(XMVECTOR(*this), XMVECTOR(Q1), XMVECTOR(Q2), f, g);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	三角形の1つ目のクオータニオンthisに、<br/>
		指定されたクオータニオンとベクトルを使用して、重心座標のポイントを＊thisに設定する<br />
		ベクトルfとgはそれぞれ要素が同じ値にする
		@param[in]	Q1	三角形の2つ目のクオータニオン
		@param[in]	Q2	三角形の3つ目のクオータニオン
		@param[in]	f	加重係数（ベクトル）
		@param[in]	g	加重係数（ベクトル）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void BaryCentricV(const Quaternion& Q1, const Quaternion& Q2,
			const Vector4& f, const Vector4& g) {
			*this = (Quaternion)XMQuaternionBaryCentricV(XMVECTOR(*this), XMVECTOR(Q1), XMVECTOR(Q2), XMVECTOR(f), XMVECTOR(g));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの共役をthisに設定する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Conjugate() {
			*this = (Quaternion)XMQuaternionConjugate(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisともう一つのクオータニオンとの内積を計算して返す
		@param[in]	other	もう一つのクオータニオン
		@return	内積
		*/
		//--------------------------------------------------------------------------------------
		float Dot(const Quaternion& other)const {
			return ((Vector4)XMQuaternionDot(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの指数をthisに設定する<br />
		入力のw要素は無視される
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Exp() {
			*this = (Quaternion)XMQuaternionExp(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisに単位クオータニオンを設定する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Identity() {
			*this = (Quaternion)XMQuaternionIdentity();
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisを反転する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Inverse() {
			*this = (Quaternion)XMQuaternionInverse(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの長さを返す
		@return	thisの長さ
		*/
		//--------------------------------------------------------------------------------------
		float Length() const {
			return ((Vector4)XMQuaternionLength(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの長さの2乗を返す
		@return	thisの長さの2乗
		*/
		//--------------------------------------------------------------------------------------
		float LengthSq() const {
			return  ((Vector4)XMQuaternionLengthSq(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの自然対数をthisに設定する<br />
		thisは正規化しておく
		@return	thisの長さの2乗
		*/
		//--------------------------------------------------------------------------------------
		void Ln() {
			*this = (Quaternion)XMQuaternionLn(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisともう１つのクオータニオンを乗算(回転を追加)してthisに設定する
		@param[in]	other	もう１つのクオータニオン
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Multiply(const Quaternion& other) {
			*this = (Quaternion)XMQuaternionMultiply(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisを正規化する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Normalize() {
			*this = (Quaternion)XMQuaternionNormalize(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisに正規化の予測値を設定する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void NormalizeEst() {
			*this = (Quaternion)XMQuaternionNormalizeEst(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの長さの逆数を返す
		@return	thisの長さの逆数
		*/
		//--------------------------------------------------------------------------------------
		float ReciprocalLength()const {
			return ((Vector4)XMVector4ReciprocalLength(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	回転軸と角度からクオータニオンを作成しthisに設定する
		@param[in]	Vec	回転軸を表す３Ｄベクトル
		@param[in]	Angle	回転角度（時計回りラジアン）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RotationAxis(const Vector3& Vec, float Angle) {
			*this = XMQuaternionRotationAxis(XMVECTOR(Vec), Angle);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	回転行列からクオータニオンをthisに設定する
		@param[in]	m	回転行列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RotationMatrix(const XMMATRIX& m) {
			*this = (Quaternion)XMQuaternionRotationMatrix(m);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	回転行列からクオータニオンをthisに設定する
		@param[in]	m	回転行列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		inline void RotationMatrix(const Matrix4X4& m);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	正規化された回転軸と角度からクオータニオンを作成しthisに設定する
		@param[in]	Vec	回転軸を表す正規化された３Ｄベクトル
		@param[in]	Angle	回転角度（時計回りラジアン）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RotationNormal(const Vector3& Vec, float Angle) {
			*this = (Quaternion)XMQuaternionRotationNormal(XMVECTOR(Vec), Angle);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各軸の回転からクオータニオンを作成しthisに設定する<br />
		回転はRollPitchYaw（Z、X、Y）の順で行われる
		@param[in]	Pitch	X軸回転（ラジアン）
		@param[in]	Yaw	Y軸回転（ラジアン）
		@param[in]	Roll	Z軸回転（ラジアン）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RotationRollPitchYaw(float Pitch, float Yaw, float Roll) {
			*this = (Quaternion)XMQuaternionRotationRollPitchYaw(Pitch, Yaw, Roll);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	3D回転ベクトルからクオータニオンを作成しthisに設定する<br />
		回転はRollPitchYaw（Z、X、Y）の順で行われる
		@param[in]	Vec	回転を表す３Ｄベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RotationRollPitchYawFromVector(const Vector3& Vec) {
			*this = (Quaternion)XMQuaternionRotationRollPitchYawFromVector(XMVECTOR(Vec));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	2つのクオータニオンから係数で補間されたクオータニオンを作成しthisに設定する<br/>
		係数が0の場合はQ0、1.0ならQ1と同じものを設定する
		@param[in]	Qt0	補間元（正規化されたクオータニオン0）
		@param[in]	Qt1	補間元（正規化されたクオータニオン1）
		@param[in]	t	補間係数（0.0fから1.0fの間を指定）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Slerp(const Quaternion& Qt0, const Quaternion& Qt1, float t) {
			*this = XMQuaternionSlerp(XMVECTOR(Qt0), XMVECTOR(Qt1), t);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisともう一つのクオータニオンから係数で補間されたクオータニオンを作成しthisに設定する<br/>
		係数が0の場合はthis、1.0ならotherと同じものを設定する
		@param[in]	other	補間元（正規化されたもう一つのクオータニオン）
		@param[in]	t	補間係数（0.0fから1.0fの間を指定）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Slerp(const Quaternion& other, float t) {
			Normalize();
			*this = XMQuaternionSlerp(XMVECTOR(*this), XMVECTOR(other), t);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	2つのクオータニオンから係数で補間されたクオータニオンを作成しthisに設定する<br/>
		係数が0の場合はQ0、1.0ならQ1と同じものを設定する
		@param[in]	Qt0	補間元（正規化されたクオータニオン0）
		@param[in]	Qt1	補間元（正規化されたクオータニオン1）
		@param[in]	Vec	補間係数（すべての要素を0.0fから1.0fの間の同じ値を指定）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SlerpV(const Quaternion& Qt0, const Quaternion& Qt1, const Vector4& Vec) {
			*this = XMQuaternionSlerpV(XMVECTOR(Qt0), XMVECTOR(Qt1), XMVECTOR(Vec));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisともう一つのクオータニオンから係数で補間されたクオータニオンを作成しthisに設定する<br/>
		係数が0の場合はthis、1.0ならotherと同じものを設定する
		@param[in]	other	補間元（正規化されたもう一つのクオータニオン）
		@param[in]	Vec	補間係数（すべての要素を0.0fから1.0fの間の同じ値を指定）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SlerpV(const Quaternion& other, const Vector4& Vec) {
			*this = XMQuaternionSlerpV(XMVECTOR(*this), XMVECTOR(other), XMVECTOR(Vec));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	球状平方補間を使用して、4 つの単位クオータニオン間を補間しthisに設定する<br/>
		Q1、Q2、Q3はQuaternionEX::SquadSetup関数で作成する
		@param[in]	Qt0	正規化されたクオータニオン0
		@param[in]	Qt1	正規化されたクオータニオン1
		@param[in]	Qt2	正規化されたクオータニオン2
		@param[in]	Qt3	正規化されたクオータニオン3
		@param[in]	t	補間制御係数
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Squad(const Quaternion& Qt0, const Quaternion& Qt1, const Quaternion& Qt2, const Quaternion& Qt3, float t) {
			*this = XMQuaternionSquad(XMVECTOR(Qt0), XMVECTOR(Qt1), XMVECTOR(Qt2), XMVECTOR(Qt3), t);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	球状平方補間を使用して、4 つの単位クオータニオン間を補間しthisに設定する<br/>
		Q1、Q2、Q3はQuaternionEX::SquadSetup関数で作成する
		@param[in]	Qt0	正規化されたクオータニオン0
		@param[in]	Qt1	正規化されたクオータニオン1
		@param[in]	Qt2	正規化されたクオータニオン2
		@param[in]	Qt3	正規化されたクオータニオン3
		@param[in]	Vec	補間制御係数（すべての要素を0.0fから1.0fの間の同じ値を指定）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SquadV(const Quaternion& Qt0, const Quaternion& Qt1, const Quaternion& Qt2, const Quaternion& Qt3, const Vector4& Vec) {
			*this = XMQuaternionSquadV(XMVECTOR(Qt0), XMVECTOR(Qt1), XMVECTOR(Qt2), XMVECTOR(Qt3), XMVECTOR(Vec));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisクオータニオンから、回転軸と回転角度を得る<br />
		pVecには回転軸ベクトル、pAngleには角度が設定される
		@param[out]	pVec	回転軸を得る３Ｄベクトル
		@param[out]	pAngle	回転角度を得る変数
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void ToAxisAngle(Vector3* pVec, float* pAngle)const {
			XMVECTOR Vec(*pVec);
			XMQuaternionToAxisAngle(&Vec, pAngle, XMVECTOR(*this));
			*pVec = Vec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisクオータニオンから、回転軸と回転角度を得る<br />
		rVecには回転軸ベクトル、rAngleには角度が設定される
		@param[out]	rVec	回転軸を得る３Ｄベクトル
		@param[out]	rAngle	回転角度を得る変数
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void ToAxisAngle(Vector3& rVec, float& rAngle)const {
			XMVECTOR Vec(rVec);
			XMQuaternionToAxisAngle(&Vec, &rAngle, XMVECTOR(*this));
			rVec = Vec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Lineに対してビルボード角度をthisに設定する
		@param[in]	Line	計算元となる線
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		inline void Billboard(const Vector3& Line);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Lineに対してフェイシング角度をthisに設定する
		@param[in]	Line	計算元となる線(オブジェクトからカメラ位置を引いたもの)
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		inline void Facing(const Vector3& Line);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	 Lineに対してY軸フェイシング角度をthisに設定する
		@param[in]	Line	計算元となる線(オブジェクトからカメラ位置を引いたもの)
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		inline void FacingY(const Vector3& Line);
	};

	//--------------------------------------------------------------------------------------
	///	4X4行列を表す構造体
	//--------------------------------------------------------------------------------------
	struct Matrix4X4 : public XMFLOAT4X4 {
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ(Identityに初期化)
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4() :XMFLOAT4X4() {
			Identity();
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	other	設定元
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4(const XMMATRIX& other) :
			XMFLOAT4X4() {
			XMMATRIX temp = other;
			XMStoreFloat4x4(this, temp);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ(各値設定)
		@param[in]	m00	設定元00
		@param[in]	m01	設定元01
		@param[in]	m02	設定元02
		@param[in]	m03	設定元03
		@param[in]	m10	設定元10
		@param[in]	m11	設定元11
		@param[in]	m12	設定元12
		@param[in]	m13	設定元13
		@param[in]	m20	設定元20
		@param[in]	m21	設定元21
		@param[in]	m22	設定元22
		@param[in]	m23	設定元23
		@param[in]	m30	設定元30
		@param[in]	m31	設定元31
		@param[in]	m32	設定元32
		@param[in]	m33	設定元33
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4(float m00, float m01, float m02, float m03,
			float m10, float m11, float m12, float m13,
			float m20, float m21, float m22, float m23,
			float m30, float m31, float m32, float m33) :
			XMFLOAT4X4(m00, m01, m02, m03,
				m10, m11, m12, m13,
				m20, m21, m22, m23,
				m30, m31, m32, m33) {}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ(XMFLOAT4X4から設定)
		@param[in]	m	設定元(XMFLOAT4X4)
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4(const XMFLOAT4X4& m) :
			XMFLOAT4X4(m._11, m._12, m._13, m._14,
				m._21, m._22, m._23, m._24,
				m._31, m._32, m._33, m._34,
				m._41, m._42, m._43, m._44) {}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コピーコンストラクタ
		@param[in]	other	設定元(Matrix4X4)
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4(const Matrix4X4& other) :
			XMFLOAT4X4() {
			for (UINT i = 0; i <4; i++) {
				m[i][0] = other.m[i][0];
				m[i][1] = other.m[i][1];
				m[i][2] = other.m[i][2];
				m[i][3] = other.m[i][3];
			}
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ(スケーリング、クオータニオン、移動)から設定
		@param[in]	Scaling	スケーリング
		@param[in]	RotationQuaternion	回転クオータニオン
		@param[in]	Translation	移動
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4(const Vector3& Scaling,
			const Quaternion& RotationQuaternion,
			const Vector3& Translation) :
			XMFLOAT4X4() {
			DefTransformation(Scaling, RotationQuaternion, Translation);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ<br/>
		アフィン変換（スケーリング、回転の中心座標、クオータニオン、平行移動）から設定する
		@param[in]	Scaling	スケーリング
		@param[in]	RotOrigin	回転の中心
		@param[in]	RotationQuaternion	クオータニオン
		@param[in]	Translation	平行移動
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4(const Vector3& Scaling, const Vector3& RotOrigin,
			const Quaternion& RotationQuaternion, const Vector3& Translation) {
			*this = (Matrix4X4)XMMatrixAffineTransformation(XMVECTOR(Scaling), XMVECTOR(RotOrigin),
				XMVECTOR(RotationQuaternion), XMVECTOR(Translation));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ(スケーリング、回転ベクトル、移動)から設定
		@param[in]	Scaling	スケーリング
		@param[in]	Rotation	回転ベクトル
		@param[in]	Translation	移動
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4(const Vector3& Scaling,
			const Vector3& Rotation,
			const Vector3& Translation) :
			XMFLOAT4X4() {
			DefTransformation(Scaling, Rotation, Translation);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	XMMATRIXへのキャスト（thisをキャストして返す）
		@return	XMMATRIX型の値
		*/
		//--------------------------------------------------------------------------------------
		operator XMMATRIX() const {
			Matrix4X4 temp = *this;
			XMMATRIX m = XMLoadFloat4x4(&temp);
			return m;
		}
		//比較
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つの行列と等しいかどうかを検証する(UINT版)
		@param[in]	other	比較元
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool EqualInt(const Matrix4X4& other)const {
			auto m = XMMATRIX(*this);
			auto o = XMMATRIX(other);
			for (UINT i = 0; i < 4; i++) {
				auto v = (Vector4)XMVectorEqualInt(m.r[i], o.r[i]);
				if (!v.x || !v.y || !v.z || !v.w) {
					return false;
				}
			}
			return true;
		}

		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つの行列と等しいかどうかを検証する
		@param[in]	other	比較元
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Equal(const Matrix4X4& other)const {
			for (UINT i = 0; i <4; i++) {
				if (m[i][0] != other.m[i][0]){
					return false;
				}
				if (m[i][1] != other.m[i][1]){
					return false;
				}
				if (m[i][2] != other.m[i][2]){
					return false;
				}
				if (m[i][3] != other.m[i][3]){
					return false;
				}
			}
			return true;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つの行列と等しいかどうかを検証する
		@param[in]	other	比較元
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator==(const Matrix4X4& other)const {
			return  Equal(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つの行列と等しくないかどうかを検証する
		@param[in]	other	比較元
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool NotEqual(const Matrix4X4& other)const {
			for (UINT i = 0; i <4; i++) {
				if (m[i][0] != other.m[i][0]){
					return true;
				}
				if (m[i][1] != other.m[i][1]){
					return true;
				}
				if (m[i][2] != other.m[i][2]){
					return true;
				}
				if (m[i][3] != other.m[i][3]){
					return true;
				}
			}
			return false;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つの行列と等しくないかどうかを検証する
		@param[in]	other	比較元
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator!=(const Matrix4X4& other)const {
			return  NotEqual(other);
		}
		//	多重定義
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元
		@return	*this
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4& operator=(const Matrix4X4& other) {
			//自己代入の抑制
			if (this != &other) {
				for (UINT i = 0; i <4; i++) {
					m[i][0] = other.m[i][0];
					m[i][1] = other.m[i][1];
					m[i][2] = other.m[i][2];
					m[i][3] = other.m[i][3];
				}
			}
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	XMMATRIXから代入
		@param[in]	other	コピー元
		@return	*this
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4& operator=(const XMMATRIX& other) {
			XMMATRIX temp = other;
			XMStoreFloat4x4(this, temp);
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加加算
		@param[in]	other	追加元
		@return	*this
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4& operator+=(const Matrix4X4& other) {
			XMMATRIX temp = XMMATRIX(*this);
			temp += XMMATRIX(other);
			*this = Matrix4X4(temp);
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加減算
		@param[in]	other	追加元
		@return	*this
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4& operator-=(const Matrix4X4& other) {
			XMMATRIX temp = XMMATRIX(*this);
			temp -= XMMATRIX(other);
			*this = Matrix4X4(temp);
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加乗算
		@param[in]	other	追加元
		@return	*this
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4& operator*=(const Matrix4X4& other) {
			XMMATRIX temp = XMMATRIX(*this);
			temp *= XMMATRIX(other);
			*this = Matrix4X4(temp);
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加各値乗算
		@param[in]	f	追加値
		@return	*this
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4& operator*=(float f) {
			XMMATRIX temp = XMMATRIX(*this);
			temp *= f;
			*this = Matrix4X4(temp);
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加各値除算
		@param[in]	f	追加値
		@return	*this
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4& operator/=(float f) {
			if (f == 0.0f) {
				//0除算
				throw BaseException(
					L"0除算です",
					L"if(f == 0.0f)",
					L"Matrix4X4::operator/=()"
					);
			}
			XMMATRIX temp = XMMATRIX(*this);
			temp /= f;
			*this = Matrix4X4(temp);
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisとの加算
		@param[in]	other	加算相手
		@return	*this
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4 operator+ (const Matrix4X4& other) const {
			Matrix4X4 temp(*this);
			temp += other;
			return temp;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisとの減算
		@param[in]	other	減算相手
		@return	*this
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4 operator- (const Matrix4X4& other) const {
			Matrix4X4 temp(*this);
			temp -= other;
			return temp;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisとの乗算
		@param[in]	other	乗算相手
		@return	*this
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4 operator* (const Matrix4X4& other) const {
			Matrix4X4 temp(*this);
			temp *= other;
			return temp;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisとの各値乗算
		@param[in]	f	乗算値
		@return	*this
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4 operator* (float f) const {
			Matrix4X4 temp(*this);
			temp *= f;
			return temp;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisとの各値除算
		@param[in]	f	除算値
		@return	*this
		*/
		//--------------------------------------------------------------------------------------
		Matrix4X4 operator/ (float f) const {
			Matrix4X4 temp(*this);
			temp /= f;
			return temp;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	行単位に取り出す
		@param[in]	i	行のインデックス
		@return	各行のVector4
		*/
		//--------------------------------------------------------------------------------------
		Vector4 operator[] (int i) const {
			Vector4 ret;
			ret.x = m[i][0];
			ret.y = m[i][1];
			ret.z = m[i][2];
			ret.w = m[i][3];
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	個別アクセス
		@param[in]	Row	行
		@param[in]	Col	列
		@return	指定場所の値
		*/
		//--------------------------------------------------------------------------------------
		float Get(UINT Row, UINT Col) const{
			if (Row > 3 || Col > 3) {
				throw BaseException(
					L"行列の範囲外です",
					L"if(Row > 3 || Col > 3)",
					L"Matrix4X4::Get()"
					);
			}
			return m[Row][Col];
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	個別設定
		@param[in]	Row	行
		@param[in]	Col	列
		@param[in]	f	設定値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Set(UINT Row, UINT Col, float f) {
			if (Row > 3 || Col > 3) {
				throw BaseException(
					L"行列の範囲外です",
					L"if(Row > 3 || Col > 3)",
					L"Matrix4X4::Set()"
					);
			}
			m[Row][Col] = f;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	this行列内の位置情報を取得する(直接行列から取り出す)
		@return	位置情報ベクトル
		*/
		//--------------------------------------------------------------------------------------
		Vector3 PosInMatrixSt()const {
			Vector3 Vec;
			Vec.x = _41;
			Vec.y = _42;
			Vec.z = _43;
			return Vec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	this行列内の位置情報を取得する(XMMAth関数を使用)
		@return	位置情報ベクトル
		*/
		//--------------------------------------------------------------------------------------
		Vector3 PosInMatrix()const {
			Vector3 Vec(0, 0, 0);
			XMVECTOR Scale;
			XMVECTOR Qt;
			XMVECTOR Translation;
			if (XMMatrixDecompose(&Scale, &Qt, &Translation, XMMATRIX(*this))) {
				Vec = Translation;
			}
			return Vec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	this行列内のスケーリングを取得する(XMMAth関数を使用)
		@return	スケーリングベクトル
		*/
		//--------------------------------------------------------------------------------------
		Vector3 ScaleInMatrix()const {
			Vector3 Vec(1.0f, 1.0f, 1.0f);
			XMVECTOR Scale;
			XMVECTOR Qt;
			XMVECTOR Translation;
			if (XMMatrixDecompose(&Scale, &Qt, &Translation, XMMATRIX(*this))) {
				Vec = Scale;
			}
			return Vec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	this行列内の回転を取得する(XMMAth関数を使用)
		@return	回転クオータニオン
		*/
		//--------------------------------------------------------------------------------------
		Quaternion QtInMatrix() const {
			Quaternion RetQt;
			XMVECTOR Scale;
			XMVECTOR Qt;
			XMVECTOR Translation;
			if (XMMatrixDecompose(&Scale, &Qt, &Translation, XMMATRIX(*this))) {
				RetQt = Qt;
			}
			return RetQt;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	0スケールをなくす（0スケーリングを0.0001に変更する）<br />
		ユーティリティ的に使用（行列とは直接関係ない）
		@param[out]	Scale	なくすスケーリング
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		static void GetSafeScale(Vector3& Scale) {
			if (Scale.x == 0.0f) {
				Scale.x = 0.0001f;
			}
			if (Scale.y == 0.0f) {
				Scale.y = 0.0001f;
			}
			if (Scale.z == 0.0f) {
				Scale.z = 0.0001f;
			}
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	this行列内のX軸傾きを取得する<br />
		スケーリングに0があった場合近似値になる
		@return	X軸の傾き
		*/
		//--------------------------------------------------------------------------------------
		Vector3 RotXInMatrix()const {
			Vector3 ret(_11, _12, _13);
			Vector3 Scale = ScaleInMatrix();
			GetSafeScale(Scale);
			ret.x /= Scale.x;
			ret.y /= Scale.x;
			ret.z /= Scale.x;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	this行列内のY軸傾きを取得する<br />
		スケーリングに0があった場合近似値になる
		@return	Y軸の傾き
		*/
		//--------------------------------------------------------------------------------------
		Vector3 RotYInMatrix()const {
			Vector3 ret(_21, _22, _23);
			Vector3 Scale = ScaleInMatrix();
			GetSafeScale(Scale);
			ret.x /= Scale.y;
			ret.y /= Scale.y;
			ret.z /= Scale.y;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	this行列内のZ軸傾きを取得する<br />
		スケーリングに0があった場合近似値になる
		@return	Z軸の傾き
		*/
		//--------------------------------------------------------------------------------------
		Vector3 RotZInMatrix()const {
			Vector3 ret(_31, _32, _33);
			Vector3 Scale = ScaleInMatrix();
			GetSafeScale(Scale);
			ret.x /= Scale.z;
			ret.y /= Scale.z;
			ret.z /= Scale.z;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisと行列を比べ移動のみの違いであればtrueを返す(全く同じ場合もtrue)
		@param[in]	m	演算する行列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		bool IsNotTranslationOnly(const Matrix4X4& m)const {
			Matrix4X4 Tmp = m;
			Tmp._41 = this->_41;
			Tmp._42 = this->_42;
			Tmp._43 = this->_43;
			return Tmp == *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アフィン変換（スケーリング、回転の中心座標、クオータニオン、平行移動）から行列を作成しthisに設定する
		@param[in]	Scaling	スケーリング
		@param[in]	RotOrigin	回転の中心
		@param[in]	RotationQuaternion	クオータニオン
		@param[in]	Translation	平行移動
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void AffineTransformation(const Vector3& Scaling, const Vector3& RotOrigin,
			const Quaternion& RotationQuaternion, const Vector3& Translation) {
			*this = (Matrix4X4)XMMatrixAffineTransformation(XMVECTOR(Scaling), XMVECTOR(RotOrigin),
				XMVECTOR(RotationQuaternion), XMVECTOR(Translation));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アフィン変換（スケーリング、回転の中心座標、回転値（ラジアン）、平行移動）から2D行列を作成しthisに設定する
		@param[in]	Scaling	スケーリング
		@param[in]	RotOrigin	回転の中心
		@param[in]	Rotation	回転
		@param[in]	Translation	平行移動
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void AffineTransformation2D(const Vector2& Scaling,
			const Vector2& RotOrigin, float Rotation, const Vector2& Translation) {
			*this = (Matrix4X4)XMMatrixAffineTransformation2D(XMVECTOR(Scaling), XMVECTOR(RotOrigin),
				Rotation, XMVECTOR(Translation));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisからスケーリング、回転、平行移動を取り出す。失敗すれば例外
		@param[out]	rScaling	スケーリング
		@param[out]	rQt	クオータニオン
		@param[out]	rTranslation	平行移動
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Decompose(Vector3& rScaling, Quaternion& rQt,
			Vector3& rTranslation)const {
			XMVECTOR Scale;
			XMVECTOR Qt;
			XMVECTOR Translation;
			if (XMMatrixDecompose(&Scale, &Qt, &Translation, XMMATRIX(*this))) {
				rScaling = Scale;
				rQt = Qt;
				rTranslation = Translation;
			}
			else {
				throw BaseException(
					L"行列のデコンポーズに失敗しました",
					L"if(!XMMatrixDecompose(&Scale, &Qt, &Translation, XMMATRIX(*this)))",
					L"Matrix4X4::Decompose()"
					);
			}
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	スケーリングを1.0にした行列にthisを変換する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void ScaleIdentity() {
			Vector3 Scale, Translation;
			Quaternion Qt;
			Decompose(Scale, Qt, Translation);
			Scale = Vector3(1.0f, 1.0f, 1.0f);
			DefTransformation(Scale, Qt, Translation);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの行列式を返す
		@return	作成した行列式（Vector4の各要素に入る）
		*/
		//--------------------------------------------------------------------------------------
		Vector4 Determinant()const {
			return (Vector4)XMMatrixDeterminant(XMMATRIX(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	単位行列をthisに設定する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Identity() {
			*this = (Matrix4X4)XMMatrixIdentity();
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	逆行列をthisに設定する。pVecには行列式が入る
		@param[out]	pVec	行列式を受け取るベクトルのポインタ
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Inverse(Vector4* pVec) {
			XMVECTOR Vec(*pVec);
			*this = (Matrix4X4)XMMatrixInverse(&Vec, XMMATRIX(*this));
			*pVec = Vec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	逆行列をthisに設定する。rVecには行列式が入る
		@param[out]	rVec	行列式を受け取るベクトルの参照
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Inverse(Vector4& rVec) {
			XMVECTOR Vec(rVec);
			*this = (Matrix4X4)XMMatrixInverse(&Vec, XMMATRIX(*this));
			rVec = Vec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisが単位行列かどうかを検証する
		@return	単位行列ならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsIdentity()const {
			return XMMatrixIsIdentity(XMMATRIX(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisのいずれかの要素が正または負の無限大かどうかを検証する
		@return	正または負の無限大ならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsInfinite()const {
			return XMMatrixIsInfinite(XMMATRIX(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisのいずれかの要素がNaNかどうかを検証する
		@return	NaNならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsNaN()const {
			return XMMatrixIsNaN(XMMATRIX(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	左手座標ビュー行列を作成しthisに設定する
		@param[in]	Eye	カメラ位置
		@param[in]	At	カメラ視点
		@param[in]	Up	カメラ傾き（通常<0,1,0>）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void LookAtLH(const Vector3& Eye, const Vector3& At, const Vector3& Up) {
			*this = (Matrix4X4)XMMatrixLookAtLH(
				XMVECTOR(Eye),
				XMVECTOR(At),
				XMVECTOR(Up));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	右手座標ビュー行列を作成しthisに設定する
		@param[in]	Eye	カメラ位置
		@param[in]	At	カメラ視点
		@param[in]	Up	カメラ傾き（通常<0,1,0>）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void LookAtRH(const Vector3& Eye, const Vector3& At, const Vector3& Up) {
			*this = (Matrix4X4)XMMatrixLookAtRH(
				XMVECTOR(Eye),
				XMVECTOR(At),
				XMVECTOR(Up));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	カメラ位置、向き、傾きから左手座標ビュー行列を作成しthisに設定する
		@param[in]	Eye	カメラ位置
		@param[in]	EyeDirection	カメラ向き
		@param[in]	Up	カメラ傾き（通常<0,1,0>）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void LookToLH(const Vector3& Eye, const Vector3& EyeDirection, const Vector3& Up) {
			*this = (Matrix4X4)XMMatrixLookToLH(
				XMVECTOR(Eye),
				XMVECTOR(EyeDirection),
				XMVECTOR(Up));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	カメラ位置、向き、傾きから右手座標ビュー行列を作成しthisに設定する
		@param[in]	Eye	カメラ位置
		@param[in]	EyeDirection	カメラ向き
		@param[in]	Up	カメラ傾き（通常<0,1,0>）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void LookToRH(const Vector3& Eye, const Vector3& EyeDirection, const Vector3& Up) {
			*this = (Matrix4X4)XMMatrixLookToRH(
				XMVECTOR(Eye),
				XMVECTOR(EyeDirection),
				XMVECTOR(Up));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisと行列の積をthisに設定する
		@param[in]	m	演算する行列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Multiply(const Matrix4X4& m) {
			*this = (Matrix4X4)XMMatrixMultiply(XMMATRIX(*this), XMMATRIX(m));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisと行列の積の転置行列をthisに設定する
		@param[in]	m	演算する行列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void MultiplyTranspose(const Matrix4X4& m) {
			*this = (Matrix4X4)XMMatrixMultiplyTranspose(XMMATRIX(*this), XMMATRIX(m));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	左手座標系の正射影行列をthisに設定する
		@param[in]	ViewWidth	幅
		@param[in]	ViewHeight	高さ
		@param[in]	NearZ	奥行手前
		@param[in]	FarZ	奥行奥
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void OrthographicLH(float ViewWidth, float ViewHeight, float NearZ, float FarZ) {
			*this = (Matrix4X4)XMMatrixOrthographicLH(ViewWidth, ViewHeight, NearZ, FarZ);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	右手座標系の正射影行列をthisに設定する
		@param[in]	ViewWidth	幅
		@param[in]	ViewHeight	高さ
		@param[in]	NearZ	奥行手前
		@param[in]	FarZ	奥行奥
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void OrthographicRH(float ViewWidth, float ViewHeight, float NearZ, float FarZ) {
			*this = (Matrix4X4)XMMatrixOrthographicRH(ViewWidth, ViewHeight, NearZ, FarZ);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	左手座標系のカスタム正射影行列をthisに設定する
		@param[in]	ViewLeft	左
		@param[in]	ViewRight	右
		@param[in]	ViewBottom	下
		@param[in]	ViewTop	上
		@param[in]	NearZ	奥行手前
		@param[in]	FarZ	奥行奥
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void OrthographicOffCenterLH(float ViewLeft, float ViewRight, float ViewBottom, float ViewTop, float NearZ, float FarZ) {
			*this = (Matrix4X4)XMMatrixOrthographicOffCenterLH(
				ViewLeft, ViewRight, ViewBottom, ViewTop, NearZ, FarZ);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	右手座標系のカスタム正射影行列をthisに設定する
		@param[in]	ViewLeft	左
		@param[in]	ViewRight	右
		@param[in]	ViewBottom	下
		@param[in]	ViewTop	上
		@param[in]	NearZ	奥行手前
		@param[in]	FarZ	奥行奥
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void OrthographicOffCenterRH(float ViewLeft, float ViewRight, float ViewBottom, float ViewTop, float NearZ, float FarZ) {
			*this = (Matrix4X4)XMMatrixOrthographicOffCenterRH(
				ViewLeft, ViewRight, ViewBottom, ViewTop, NearZ, FarZ);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	視野に基づいて、左手座標系のパースペクティブ射影行列をthisに設定する
		@param[in]	FovAngleY	トップダウン視野角度
		@param[in]	AspectHByW	ビュー空間の高さと幅のアスペクト比
		@param[in]	NearZ	奥行手前
		@param[in]	FarZ	奥行奥
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void PerspectiveFovLH(float FovAngleY, float AspectHByW, float NearZ, float FarZ) {
			*this = (Matrix4X4)XMMatrixPerspectiveFovLH(FovAngleY, AspectHByW, NearZ, FarZ);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	視野に基づいて、右手座標系のパースペクティブ射影行列をthisに設定する
		@param[in]	FovAngleY	トップダウン視野角度
		@param[in]	AspectHByW	ビュー空間の高さと幅のアスペクト比
		@param[in]	NearZ	奥行手前
		@param[in]	FarZ	奥行奥
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void PerspectiveFovRH(float FovAngleY, float AspectHByW, float NearZ, float FarZ) {
			*this = (Matrix4X4)XMMatrixPerspectiveFovRH(FovAngleY, AspectHByW, NearZ, FarZ);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	左手座標系のパースペクティブ射影行列をthisに設定する
		@param[in]	ViewWidth	近くのクリップ面の視錐台の幅
		@param[in]	ViewHeight	近くのクリップ面の視錐台の高さ
		@param[in]	NearZ	奥行手前
		@param[in]	FarZ	奥行奥
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void PerspectiveLH(float ViewWidth, float ViewHeight, float NearZ, float FarZ) {
			*this = (Matrix4X4)XMMatrixPerspectiveLH(ViewWidth, ViewHeight, NearZ, FarZ);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	右手座標系のパースペクティブ射影行列をthisに設定する
		@param[in]	ViewWidth	近くのクリップ面の視錐台の幅
		@param[in]	ViewHeight	近くのクリップ面の視錐台の高さ
		@param[in]	NearZ	奥行手前
		@param[in]	FarZ	奥行奥
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void PerspectiveRH(float ViewWidth, float ViewHeight, float NearZ, float FarZ) {
			*this = (Matrix4X4)XMMatrixPerspectiveRH(ViewWidth, ViewHeight, NearZ, FarZ);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	カスタム バージョンの左手座標系パースペクティブ射影行列をthisに設定する
		@param[in]	ViewLeft	クリップ視錐台の左側のx座標
		@param[in]	ViewRight	クリップ視錐台の右側のx座標
		@param[in]	ViewBottom	クリップ視錐台の下側のy座標
		@param[in]	ViewTop	クリップ視錐台の上側のy座標
		@param[in]	NearZ	奥行手前
		@param[in]	FarZ	奥行奥
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void PerspectiveOffCenterLH(float ViewLeft, float ViewRight, float ViewBottom, float ViewTop,
			float NearZ, float FarZ) {
			*this = (Matrix4X4)XMMatrixPerspectiveOffCenterLH(ViewLeft, ViewRight, ViewBottom, ViewTop, NearZ, FarZ);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	カスタム バージョンの右手座標系パースペクティブ射影行列をthisに設定する
		@param[in]	ViewLeft	クリップ視錐台の左側のx座標
		@param[in]	ViewRight	クリップ視錐台の右側のx座標
		@param[in]	ViewBottom	クリップ視錐台の下側のy座標
		@param[in]	ViewTop	クリップ視錐台の上側のy座標
		@param[in]	NearZ	奥行手前
		@param[in]	FarZ	奥行奥
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void PerspectiveOffCenterRH(float ViewLeft, float ViewRight, float ViewBottom, float ViewTop,
			float NearZ, float FarZ) {
			*this = (Matrix4X4)XMMatrixPerspectiveOffCenterRH(ViewLeft, ViewRight, ViewBottom, ViewTop, NearZ, FarZ);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	指定された平面を介してベクトルを反映するトランスフォーム行列を作成しthisに設定する
		@param[in]	Pln	平面
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Reflect(const Plane& Pln) {
			*this = (Matrix4X4)XMMatrixReflect(XMVECTOR(Pln));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	任意の軸を回転軸にして、回転した行列を作成しthisに設定する
		@param[in]	Axis	回転軸を表すベクトル
		@param[in]	Angle	回転角度（ラジアン）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RotationAxis(const Vector3& Axis, float Angle) {
			*this = (Matrix4X4)XMMatrixRotationAxis(XMVECTOR(Axis), Angle);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	任意の法線ベクトルを回転軸にして、回転した行列を作成しthisに設定する
		@param[in]	Axis	回転軸を記述する法線ベクトル
		@param[in]	Angle	回転角度（ラジアン）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RotationNormal(const Vector3& NormalAxis, float Angle) {
			*this = (Matrix4X4)XMMatrixRotationNormal(XMVECTOR(NormalAxis), Angle);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	クオータニオンから回転行列を作成しthisに設定する
		@param[in]	Qt	回転を記述するクオータニオン
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RotationQuaternion(const Quaternion& Qt) {
			*this = (Matrix4X4)XMMatrixRotationQuaternion(XMVECTOR(Qt));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	オイラー角に基づいて回転行列を作成しthisに設定する<br />
		回転はRollPitchYaw（Z、X、Y）の順で行われる
		@param[in]	Pitch	X軸回転
		@param[in]	Yaw	Y軸回転
		@param[in]	Roll	Z軸回転
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RotationRollPitchYaw(float Pitch, float Yaw, float Roll) {
			*this = (Matrix4X4)XMMatrixRotationRollPitchYaw(Pitch, Yaw, Roll);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	オイラー角(ベクトル)に基づいて回転行列を作成しthisに設定する<br />
		回転はRollPitchYaw（Z、X、Y）の順で行われる
		@param[in]	Angles	回転を記述するベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RotationRollPitchYawFromVector(const Vector3& Angles) {
			*this = (Matrix4X4)XMMatrixRotationRollPitchYawFromVector(XMVECTOR(Angles));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	X軸回転に基づいて回転行列を作成しthisに設定する
		@param[in]	Angle	X軸回転
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RotationX(float Angle) {
			*this = (Matrix4X4)XMMatrixRotationX(Angle);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Y軸回転に基づいて回転行列を作成しthisに設定する
		@param[in]	Angle	Y軸回転
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RotationY(float Angle) {
			*this = (Matrix4X4)XMMatrixRotationY(Angle);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Z軸回転に基づいて回転行列を作成しthisに設定する
		@param[in]	Angle	Z軸回転
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RotationZ(float Angle) {
			*this = (Matrix4X4)XMMatrixRotationZ(Angle);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	x軸、y軸、およびz軸に沿ってスケーリングした行列を作成しthisに設定する
		@param[in]	ScaleX	X軸に沿ったスケーリング
		@param[in]	ScaleY	Y軸に沿ったスケーリング
		@param[in]	ScaleZ	Z軸に沿ったスケーリング
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Scaling(float ScaleX, float ScaleY, float ScaleZ) {
			*this = (Matrix4X4)XMMatrixScaling(ScaleX, ScaleY, ScaleZ);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ベクトルに沿ってスケーリングした行列を作成しthisに設定する
		@param[in]	Scale	スケーリングを記述するベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void ScalingFromVector(const Vector3& Scale) {
			*this = (Matrix4X4)XMMatrixScalingFromVector(XMVECTOR(Scale));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各値を設定した行列を作成しthisに設定する
		@param[in]	m00	設定元00
		@param[in]	m01	設定元01
		@param[in]	m02	設定元02
		@param[in]	m03	設定元03
		@param[in]	m10	設定元10
		@param[in]	m11	設定元11
		@param[in]	m12	設定元12
		@param[in]	m13	設定元13
		@param[in]	m20	設定元20
		@param[in]	m21	設定元21
		@param[in]	m22	設定元22
		@param[in]	m23	設定元23
		@param[in]	m30	設定元30
		@param[in]	m31	設定元31
		@param[in]	m32	設定元32
		@param[in]	m33	設定元33
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Set(
			float m00, float m01, float m02, float m03,
			float m10, float m11, float m12, float m13,
			float m20, float m21, float m22, float m23,
			float m30, float m31, float m32, float m33
			) {
			*this = (Matrix4X4)XMMatrixSet(
				m00, m01, m02, m03,
				m10, m11, m12, m13,
				m20, m21, m22, m23,
				m30, m31, m32, m33
				);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ジオメトリを平面に射影するトランスフォーム行列を作成しthisに設定する
		@param[in]	ShadowPlane	基準面
		@param[in]	LightPosition	ライトの位置
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Shadow(const Plane& ShadowPlane, const Vector4& LightPosition) {
			*this = (Matrix4X4)XMMatrixShadow(XMVECTOR(ShadowPlane), XMVECTOR(LightPosition));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	トランスフォーム行列を作成しthisに設定する
		@param[in]	ScalingOrigin	スケーリングの中心を記述する3Dベクトル
		@param[in]	ScalingOrientationQuaternion	スケーリングの向きを記述するクオータニオン
		@param[in]	Scaling	x軸、y軸、z軸のスケーリング係数を含む 3D ベクトル
		@param[in]	RotationOrigin	回転の中心を記述する3Dベクトル
		@param[in]	RotationQuaternion	RotationOrigin によって示される原点を中心とする回転を記述するクオータニオン
		@param[in]	Translation	x軸、y軸、z軸に沿った平行移動を記述する3Dベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Transformation(const Vector3& ScalingOrigin, const Quaternion& ScalingOrientationQuaternion, const Vector3& Scaling,
			const Vector3& RotationOrigin, const Quaternion& RotationQuaternion,
			const Vector3& Translation) {
			*this = (Matrix4X4)XMMatrixTransformation(
				XMVECTOR(ScalingOrigin), XMVECTOR(ScalingOrientationQuaternion), XMVECTOR(Scaling),
				XMVECTOR(RotationOrigin), XMVECTOR(RotationQuaternion),
				XMVECTOR(Translation)
				);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	2Dトランスフォーム行列をxy平面に作成しthisに設定する
		@param[in]	ScalingOrigin	スケーリングの中心を記述する2Dベクトル
		@param[in]	ScalingOrientation	スケーリング回転係数
		@param[in]	Scaling	x軸およびy軸のスケーリング係数を含む2Dベクトル
		@param[in]	RotationOrigin	回転の中心を記述する2Dベクトル
		@param[in]	Rotation	回転の角度 (ラジアン単位)
		@param[in]	Translation	x軸、y軸に沿った平行移動を記述する2Dベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Transformation2D(const Vector2& ScalingOrigin, float ScalingOrientation, const Vector2& Scaling,
			const Vector2& RotationOrigin, float Rotation,
			const Vector2& Translation) {
			*this = (Matrix4X4)XMMatrixTransformation2D(XMVECTOR(ScalingOrigin), ScalingOrientation, XMVECTOR(Scaling),
				XMVECTOR(RotationOrigin), Rotation, XMVECTOR(Translation));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	指定されたオフセットから平行移動行列を作成しthisに設定する
		@param[in]	OffsetX	X軸に沿った平行移動
		@param[in]	OffsetY	Y軸に沿った平行移動
		@param[in]	OffsetZ	Z軸に沿った平行移動
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Translation(float OffsetX, float OffsetY, float OffsetZ) {
			*this = (Matrix4X4)XMMatrixTranslation(OffsetX, OffsetY, OffsetZ);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ベクトルから平行移動行列を作成しthisに設定する
		@param[in]	Offset	x軸、y軸、z軸に沿った平行移動を記述する3Dベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void TranslationFromVector(const Vector3& Offset) {
			*this = (Matrix4X4)XMMatrixTranslationFromVector(XMVECTOR(Offset));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	行列を転置してthisに設定する
		@param[in]	m	転置する行列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Transpose(const Matrix4X4& m) {
			*this = (Matrix4X4)XMMatrixTranspose(XMMATRIX(m));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisを転置してthisに設定する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Transpose() {
			*this = (Matrix4X4)XMMatrixTranspose(XMMATRIX(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	スケーリング、回転、移動から行列を作成しthisに設定する<br />
		回転位置を中心に置いたアフィン変換である。
		@param[in]	Scaling	x軸、y軸、z軸のスケーリング係数を含む3Dベクトル
		@param[in]	RotationQuaternion	回転を記述するクオータニオン
		@param[in]	Translation	x軸、y軸、z軸に沿った平行移動を記述する3Dベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void DefTransformation(const Vector3& Scaling, const Quaternion& RotationQuaternion, const Vector3& Translation) {
			AffineTransformation(Scaling, Vector3(0, 0, 0), RotationQuaternion, Translation);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	スケーリング、回転ベクトル、移動から行列を作成しthisに設定する<br />
		回転位置を中心に置いたアフィン変換である。
		@param[in]	Scaling	x軸、y軸、z軸のスケーリング係数を含む3Dベクトル
		@param[in]	Rotation	回転を記述するベクトル
		@param[in]	Translation	x軸、y軸、z軸に沿った平行移動を記述する3Dベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void DefTransformation(const Vector3& Scaling, const Vector3& Rotation, const Vector3& Translation) {
			Quaternion Qt;
			Qt.RotationRollPitchYawFromVector(Rotation);
			Qt.Normalize();
			AffineTransformation(Scaling, Vector3(0, 0, 0), Qt, Translation);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	スケーリング、移動、回転から行列を作成しthisに設定する<br />
		回転より移動を先に行う
		@param[in]	Scaling	x軸、y軸、z軸のスケーリング係数を含む3Dベクトル
		@param[in]	Translation	x軸、y軸、z軸に沿った平行移動を記述する3Dベクトル
		@param[in]	RotationQuaternion	回転を記述するクオータニオン
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void STRTransformation(const Vector3& Scaling, const Vector3& Translation, const Quaternion& RotationQuaternion) {
			Matrix4X4 Scale = (Matrix4X4)XMMatrixScalingFromVector(XMVECTOR(Scaling));
			Matrix4X4 Trans = (Matrix4X4)XMMatrixTranslationFromVector(XMVECTOR(Translation));
			Matrix4X4 Qt = (Matrix4X4)XMMatrixRotationQuaternion(XMVECTOR(RotationQuaternion));
			*this = Scale * Trans * Qt;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	スケーリング、移動、回転から行列を作成しthisに設定する<br />
		回転より移動を先に行う
		@param[in]	Scaling	x軸、y軸、z軸のスケーリング係数を含む3Dベクトル
		@param[in]	Translation	x軸、y軸、z軸に沿った平行移動を記述する3Dベクトル
		@param[in]	Rotation	回転を記述するベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void STRTransformation(const Vector3& Scaling, const Vector3& Translation, const Vector3& Rotation) {
			Matrix4X4 Scale = (Matrix4X4)XMMatrixScalingFromVector(XMVECTOR(Scaling));
			Matrix4X4 Trans = (Matrix4X4)XMMatrixTranslationFromVector(XMVECTOR(Translation));
			Matrix4X4 Rot = (Matrix4X4)XMMatrixRotationRollPitchYawFromVector(XMVECTOR(Rotation));
			*this = Scale * Trans * Rot;
		}
	};

	//--------------------------------------------------------------------------------------
	//	クオータニオンインラインメンバ
	//--------------------------------------------------------------------------------------
	Quaternion::Quaternion(const Matrix4X4& m) {
		*this = (Quaternion)XMQuaternionRotationMatrix(XMMATRIX(m));
	}
	void Quaternion::RotationMatrix(const Matrix4X4& m) {
		*this = (Quaternion)XMQuaternionRotationMatrix(XMMATRIX(m));
	}
	Vector3 Quaternion::GetRotation()const {
		Quaternion Temp = *this;
		Temp.Normalize();
		Matrix4X4 mt;
		mt.RotationQuaternion(Temp);
		Vector3 Rot;
		if (mt._32 == 1.0f) {
			Rot.x = XM_PI / 2.0f;
			Rot.y = 0;
			Rot.z = -atan2(mt._21, mt._11);
		}
		else if (mt._32 == -1.0f) {
			Rot.x = -XM_PI / 2.0f;
			Rot.y = 0;
			Rot.z = -atan2(mt._21, mt._11);
		}
		else {
			Rot.x = -asin(mt._32);
			Rot.y = -atan2(-mt._31, mt._33);
			Rot.z = atan2(mt._12, mt._11);
		}
		return Rot;
	}
	void Quaternion::Billboard(const Vector3& Line) {
		Vector3 Temp = Line;
		Matrix4X4 RotMatrix;
		Vector4 dammi(0, 0, 0, 0);
		Vector3 DefUp(0, 1.0f, 0);
		Vector2 TempVec2(Temp.x, Temp.z);
		if (TempVec2.Length() < 0.1f) {
			DefUp = Vector3(0, 0, 1.0f);
		}
		Temp.Normalize();
		RotMatrix.LookAtLH(Vector3(0, 0, 0), Temp, DefUp);
		RotMatrix.Inverse(&dammi);
		*this = RotMatrix.QtInMatrix();
		this->Normalize();
	}
	void Quaternion::Facing(const Vector3& Line) {
		Vector3 Temp = Line;
		Matrix4X4 RotMatrix;
		Vector4 dammi(0, 0, 0, 0);
		Vector3 DefUp(0, 1.0f, 0);
		Vector2 TempVec2(Temp.x, Temp.z);
		if (TempVec2.Length() < 0.1f) {
			DefUp = Vector3(0, 0, 1.0f);
		}
		RotMatrix.LookAtLH(Vector3(0, 0, 0), Temp, DefUp);
		RotMatrix.Inverse(&dammi);
		*this = RotMatrix.QtInMatrix();
		this->Normalize();
	}
	void Quaternion::FacingY(const Vector3& Line) {
		Vector3 Temp = Line;
		Temp.Normalize();
		this->Identity();
		this->RotationRollPitchYaw(0, atan2(Temp.x, Temp.z), 0);
		this->Normalize();
	}



}
//end of namespace basecross.

