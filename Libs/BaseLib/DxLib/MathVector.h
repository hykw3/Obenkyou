/*!
@file MathVector.h
@brief ベクトル計算の計算クラス<br />
XNAMATH のラッピング関数群
@copyright Copyright (c) 2017 WiZ Tamura Hiroki,Yamanoi Yasushi.
*/

#pragma once

#include "stdafx.h"

namespace basecross{

	struct Vector2;
	struct Vector3;
	struct Vector4;
	struct Matrix4X4;

	//--------------------------------------------------------------------------------------
	///	Vector2（2Dベクトル）構造体
	//--------------------------------------------------------------------------------------
	struct Vector2 : public XMFLOAT2 {
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		*/
		//--------------------------------------------------------------------------------------
		Vector2() :XMFLOAT2() {
			x = 0;
			y = 0;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	v2	XMFLOAT2構造体
		*/
		//--------------------------------------------------------------------------------------
		Vector2(const XMFLOAT2& v2) :XMFLOAT2(v2) {
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	other	XMVECTOR構造体
		*/
		//--------------------------------------------------------------------------------------
		Vector2(const XMVECTOR& other) :XMFLOAT2() {
			XMVECTOR temp = other;
			XMStoreFloat2(this, temp);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	other	XMVECTORF32
		*/
		//--------------------------------------------------------------------------------------
		Vector2(const XMVECTORF32& other) :XMFLOAT2() {
			XMVECTOR temp = other;
			XMStoreFloat2(this, temp);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	x	X値
		@param[in]	y	Y値
		*/
		//--------------------------------------------------------------------------------------
		Vector2(float x, float y) :
			XMFLOAT2(x, y) {
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コピーコンストラクタ
		@param[in]	other	コピー元
		*/
		//--------------------------------------------------------------------------------------
		Vector2(const Vector2& other) :XMFLOAT2() {
			x = other.x;
			y = other.y;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	x_str	X数値に変換できる文字列
		@param[in]	y_str	Y数値に変換できる文字列
		*/
		//--------------------------------------------------------------------------------------
		Vector2(wstring& x_str, wstring& y_str) {
			x = (float)_wtof(x_str.c_str());
			y = (float)_wtof(y_str.c_str());
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	XMVECTORへのキャスト（thisをキャストして返す）
		@return	XMVECTOR型の値
		*/
		//--------------------------------------------------------------------------------------
		operator XMVECTOR() const {
			XMFLOAT2 temp = *this;
			XMVECTOR Vec = XMLoadFloat2(&temp);
			return Vec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	メンバ変数への直接代入
		@param[in]	x_str	X数値に変換できる文字列
		@param[in]	y_str	Y数値に変換できる文字列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Set(wstring& x_str, wstring& y_str) {
			x = (float)_wtof(x_str.c_str());
			y = (float)_wtof(y_str.c_str());
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	メンバ変数への直接代入
		@param[in]	xx	X値
		@param[in]	yy	Y値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Set(float xx, float yy) {
			x = xx;
			y = yy;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	0初期化
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Zero() {
			x = 0;
			y = 0;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector2& operator=(const Vector2& other) {
			//自己代入の抑制
			if (this != &other) {
				x = other.x;
				y = other.y;
			}
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元(XMVECTOR)
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector2& operator=(const XMVECTOR& other) {
			XMVECTOR temp = other;
			XMStoreFloat2(this, temp);
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加加算
		@param[in]	other	加算する相手
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector2& operator+=(const Vector2& other) {
			x += other.x;
			y += other.y;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加減算
		@param[in]	other	減算する相手
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector2& operator-=(const Vector2& other) {
			x -= other.x;
			y -= other.y;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加乗算
		@param[in]	val	乗算する値
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector2& operator*=(float val) {
			x *= val;
			y *= val;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加除算
		@param[in]	val	除算する値
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector2& operator/=(float val) {
			if (val == 0.0f) {
				//0除算
				throw BaseException(
					L"0除算です",
					L"if(val == 0.0f)",
					L"Vector2::operator/=()"
					);
			}
			x /= val;
			y /= val;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	単項プラス
		@return	演算後のVector2
		*/
		//--------------------------------------------------------------------------------------
		Vector2 operator+ () const {
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	単項マイナス
		@return	演算後のVector2
		*/
		//--------------------------------------------------------------------------------------
		Vector2 operator- () const {
			Vector2 ret = *this;
			ret *= -1.0f;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	加算
		@param[in]	other	加算する相手
		@return	演算後のVector2
		*/
		//--------------------------------------------------------------------------------------
		Vector2 operator+(const Vector2& other)const {
			Vector2 ret = *this;
			ret += other;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	減算
		@param[in]	other	減算する相手
		@return	演算後のVector2
		*/
		//--------------------------------------------------------------------------------------
		Vector2 operator-(const Vector2& other)const {
			Vector2 ret = *this;
			ret -= other;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	乗算
		@param[in]	val	乗算する値
		@return	演算後のVector2
		*/
		//--------------------------------------------------------------------------------------
		Vector2 operator*(float val)const {
			Vector2 ret = *this;
			ret *= val;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	除算
		@param[in]	val	除算する値
		@return	演算後のVector2
		*/
		//--------------------------------------------------------------------------------------
		Vector2 operator/(float val)const {
			if (val == 0.0f) {
				//0除算
				throw BaseException(
					L"0除算です",
					L"if(val == 0.0f)",
					L"Vector4::operator/()"
					);
			}
			Vector2 ret = *this;
			ret /= val;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各値インデックスアクセス
		@param[in]	i	インデックス
		@return	インデックスで指定された値の参照
		*/
		//--------------------------------------------------------------------------------------
		float& operator[](int i) {
			if (i > 1 || i < 0) {
				throw BaseException(
					L"インデックスが範囲外です",
					L"if(i > 1 || i < 0)",
					L"Vector2::operator[]()"
					);
			}
			switch (i) {
			case 0:
				return x;
				break;
			case 1:
				return y;
				break;
			}
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各値インデックスアクセス（const版）
		@param[in]	i	インデックス
		@return	インデックスで指定された値の参照（const版）
		*/
		//--------------------------------------------------------------------------------------
		const float& operator[](int i) const {
			if (i > 1 || i < 0) {
				throw BaseException(
					L"インデックスが範囲外です",
					L"if(i > 1 || i < 0)",
					L"Vector2::operator[]()"
					);
			}
			switch (i) {
			case 0:
				return x;
				break;
			case 1:
				return y;
				break;
			}
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルと等しいかどうかを検証する
		@param[in]	other	相手
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Equal(const Vector2& other)const {
			return XMVector2Equal(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルと等しいかどうかを検証する(==版)
		@param[in]	other	相手
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator==(const Vector2& other)const {
			return Equal(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルと等しいかどうかを検証する。<br />
		それぞれの要素は符号なし整数として扱う。
		@param[in]	other	相手
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool EqualInt(const Vector2& other)const {
			return XMVector2EqualInt(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルより大きいかどうかを検証する
		@param[in]	other	相手
		@return	大きければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Greater(const Vector2& other)const {
			return XMVector2Greater(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルより大きいかどうかを検証する(>版)
		@param[in]	other	相手
		@return	大きければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator>(const Vector2& other)const {
			return Greater(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトル以上の大きさかどうかを検証する
		@param[in]	other	相手
		@return	以上の大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool GreaterOrEqual(const Vector2& other)const {
			return XMVector2GreaterOrEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトル以上の大きさかどうかを検証する(>=版)
		@param[in]	other	相手
		@return	以上の大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator >= (const Vector2& other)const {
			return GreaterOrEqual(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの値のいずれかが正か負の無限大かどうかを検証する。
		@return	値のいずれかが正か負の無限大ならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsInfinite() const {
			return XMVector2IsInfinite(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの値のいずれかが非数（無効値）かどうかを検証する。
		@return	値のいずれかが非数（無効値）ならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsNaN() const {
			return XMVector2IsNaN(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルより小さいかどうかを検証する。
		@param[in]	other	相手
		@return	小さければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Less(const Vector2& other)const {
			return XMVector2Less(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルより小さいかどうかを検証する(<版)。
		@param[in]	other	相手
		@return	小さければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator<(const Vector2& other)const {
			return Less(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトル以下の大きさかどうかを検証する。
		@param[in]	other	相手
		@return	以下の大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool LessOrEqual(const Vector2& other)const {
			return XMVector2LessOrEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトル以下の大きさかどうかを検証する(<=版)。
		@param[in]	other	相手
		@return	以下の大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator <= (const Vector2& other)const {
			return LessOrEqual(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルが近い大きさかどうかを検証する。
		@param[in]	other	相手
		@param[in]	Epsilon	比較する最大許容差
		@return	近い大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool NearEqual(const Vector2& other, float Epsilon)const {
			float temp = Epsilon;
			XMVECTOR VecEp = XMLoadFloat(&temp);
			return XMVector2NearEqual(XMVECTOR(*this), XMVECTOR(other), VecEp);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルと等しくないかどうかを検証する。
		@param[in]	other	相手
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool NotEqual(const Vector2& other)const {
			return XMVector2NotEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルと等しくないかどうかを検証する(!=版)。
		@param[in]	other	相手
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator!=(const Vector2& other)const {
			return NotEqual(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルと等しくないかどうかを検証する。<br />
		それぞれの要素は符号なし整数として扱う。
		@param[in]	other	相手
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool NotEqualInt(const Vector2& other)const {
			return XMVector2NotEqualInt(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	正規化したthisともう一つのつの正規化したベクトルとのラジアン角を計算し返す。<br />
		関数内で正規化はしないので、thisおよびotherはあらかじめ正規化しておく。<br />
		ベクトルのラジアン角計算では、正規化しない分速い。
		@param[in]	other	相手
		@return	ラジアン角
		*/
		//--------------------------------------------------------------------------------------
		float AngleBetweenNormals(const Vector2& other)const {
			return ((Vector2)XMVector2AngleBetweenNormals(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	正規化されたthisと正規化されたもう一つのつのベクトル間のラジアン角を予測して返す。<br />
		関数内で正規化はしないので、thisおよびotherはあらかじめ正規化しておく。<br />
		ベクトルのラジアン角計算では、正規化しない分速い。
		@param[in]	other	相手
		@return	ラジアン角
		*/
		//--------------------------------------------------------------------------------------
		float AngleBetweenNormalsEst(const Vector2& other)const {
			return ((Vector2)XMVector2AngleBetweenNormalsEst(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisともう一つのつのベクトル間のラジアン角を計算する。
		@param[in]	other	相手
		@return	ラジアン角
		*/
		//--------------------------------------------------------------------------------------
		float AngleBetweenVectors(const Vector2& other)const {
			return ((Vector2)XMVector2AngleBetweenVectors(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisをベクトルの長さを指定した大きさにクランプする。
		@param[in]	LengthMin	長さの最小値
		@param[in]	LengthMax	長さの最大値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void ClampLength(float LengthMin, float LengthMax) {
			*this = XMVector2ClampLength(XMVECTOR(*this), LengthMin, LengthMax);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisを指定した大きさにクランプする。
		@param[in]	LengthMinV	長さの最小値(ベクトル)
		@param[in]	LengthMaxV	長さの最大値(ベクトル)
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void ClampLengthV(const Vector2& LengthMinV, const Vector2& LengthMaxV) {
			*this = XMVector2ClampLengthV(XMVECTOR(*this), XMVECTOR(LengthMinV), XMVECTOR(LengthMaxV));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisとの外積を返す。
		@param[in]	other	相手
		@return	外積
		*/
		//--------------------------------------------------------------------------------------
		float Cross(const Vector2& other)const {
			return ((Vector2)XMVector2Cross(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisとの内積を返す。
		@param[in]	other	相手
		@return	内積
		*/
		//--------------------------------------------------------------------------------------
		float Dot(const Vector2& other)const {
			return ((Vector2)XMVector2Dot(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisのすべての要素が、設定された境界内にある場合はtrueを返す。
		@param[in]	other	相手
		@return	境界内にある場合はtrue
		*/
		//--------------------------------------------------------------------------------------
		bool InBounds(const Vector2& other)const {
			return XMVector2InBounds(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ベクトルの長さを返す。
		@return	ベクトルの長さ
		*/
		//--------------------------------------------------------------------------------------
		float Length() const {
			return  ((Vector2)XMVector2Length(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ベクトルの長さを予想して返す。
		@return	ベクトルの長さの予想
		*/
		//--------------------------------------------------------------------------------------
		float LengthEst() const {
			return ((Vector2)XMVector2LengthEst(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ベクトルの長さの2乗を返す。
		@return	ベクトルの長さの2乗
		*/
		//--------------------------------------------------------------------------------------
		float LengthSq() const {
			return ((Vector2)XMVector2LengthSq(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	正規化する。
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Normalize() {
			*this = XMVector2Normalize(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	正規化の予想値を設定する。
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void NormalizeEst() {
			*this = XMVector2NormalizeEst(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisに垂直なベクトルを設定する。
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Orthogonal() {
			*this = XMVector2Orthogonal(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの長さの逆数を返す。
		@return	thisの長さの逆数
		*/
		//--------------------------------------------------------------------------------------
		float ReciprocalLength()const {
			return ((Vector2)XMVector2ReciprocalLength(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの長さの逆数の予測値を返す。
		@return	thisの長さの逆数の予測値
		*/
		//--------------------------------------------------------------------------------------
		float ReciprocalLengthEst()const {
			return ((Vector2)XMVector2ReciprocalLengthEst(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisに法線ベクトルによって反射させたベクトル(入射ベクトル)を設定する。
		@param[in]	Normal	法線ベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Reflect(const Vector2& Normal) {
			*this = XMVector2Reflect(XMVECTOR(*this), XMVECTOR(Normal));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisに法線ベクトルによって屈折率で反射させたベクトル(入射ベクトル)を設定する。
		@param[in]	Normal	法線ベクトル
		@param[in]	RefractionIndex	屈折率
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Refract(const Vector2& Normal, float RefractionIndex) {
			*this = XMVector2Refract(XMVECTOR(*this), XMVECTOR(Normal), RefractionIndex);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisに法線ベクトルによって屈折率ベクトル（すべての要素が同じ値）で反射させたベクトル(入射ベクトル)を設定する。
		@param[in]	Normal	法線ベクトル
		@param[in]	RefractionIndex	屈折率
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RefractV(const Vector2& Normal, const Vector2& RefractionIndex) {
			*this = XMVector2RefractV(XMVECTOR(*this), XMVECTOR(Normal),
				XMVECTOR(RefractionIndex));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisをmによってトランスフォームされたベクトルを設定する(XMMATRIX版)。
		@param[in]	m	トランスフォームする行列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Transform(const XMMATRIX& m) {
			*this = XMVector2Transform(XMVECTOR(*this), m);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisをmによってトランスフォームされたベクトルを設定する。
		@param[in]	m	トランスフォームする行列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		inline void Transform(const Matrix4X4& m);
	};

	//--------------------------------------------------------------------------------------
	///	Vector3（3Dベクトル）構造体
	//--------------------------------------------------------------------------------------
	struct Vector3 : public XMFLOAT3 {
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		*/
		//--------------------------------------------------------------------------------------
		Vector3() :XMFLOAT3() {
			x = 0;
			y = 0;
			z = 0;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	v3	XMFLOAT3
		*/
		//--------------------------------------------------------------------------------------
		Vector3(const XMFLOAT3& v3) :XMFLOAT3(v3) {
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	other	XMVECTOR
		*/
		//--------------------------------------------------------------------------------------
		Vector3(const XMVECTOR& other) :XMFLOAT3() {
			XMVECTOR temp = other;
			XMStoreFloat3(this, temp);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	other	XMVECTORF32
		*/
		//--------------------------------------------------------------------------------------
		Vector3(const XMVECTORF32& other) :XMFLOAT3() {
			XMVECTOR temp = other;
			XMStoreFloat3(this, temp);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ（値セット）
		@param[in]	x	X値
		@param[in]	y	Y値
		@param[in]	z	Z値
		*/
		//--------------------------------------------------------------------------------------
		Vector3(float x, float y, float z) :
			XMFLOAT3(x, y, z) {
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コピーコンストラクタ
		@param[in]	other	コピー元
		*/
		//--------------------------------------------------------------------------------------
		Vector3(const Vector3& other) :XMFLOAT3() {
			x = other.x;
			y = other.y;
			z = other.z;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	x_str	X数値に変換できる文字列
		@param[in]	y_str	Y数値に変換できる文字列
		@param[in]	z_str	Z数値に変換できる文字列
		*/
		//--------------------------------------------------------------------------------------
		Vector3(wstring& x_str, wstring& y_str, wstring& z_str) {
			x = (float)_wtof(x_str.c_str());
			y = (float)_wtof(y_str.c_str());
			z = (float)_wtof(z_str.c_str());
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	XMVECTORへのキャスト（thisをキャストして返す）
		@return	XMVECTOR型の値
		*/
		//--------------------------------------------------------------------------------------
		operator XMVECTOR() const {
			XMFLOAT3 temp = *this;
			XMVECTOR Vec = XMLoadFloat3(&temp);
			return Vec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	メンバ変数への直接代入
		@param[in]	x_str	X数値に変換できる文字列
		@param[in]	y_str	Y数値に変換できる文字列
		@param[in]	z_str	Z数値に変換できる文字列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Set(wstring& x_str, wstring& y_str, wstring& z_str) {
			x = (float)_wtof(x_str.c_str());
			y = (float)_wtof(y_str.c_str());
			z = (float)_wtof(z_str.c_str());
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	メンバ変数への直接代入
		@param[in]	xx	X値
		@param[in]	yy	Y値
		@param[in]	zz	Z値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Set(float xx, float yy, float zz) {
			x = xx;
			y = yy;
			z = zz;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	0初期化
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Zero() {
			x = 0;
			y = 0;
			z = 0;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector3& operator=(const Vector3& other) {
			//自己代入の抑制
			if (this != &other) {
				x = other.x;
				y = other.y;
				z = other.z;
			}
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元(XMVECTOR)
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector3& operator=(const XMVECTOR& other) {
			XMVECTOR temp = other;
			XMStoreFloat3(this, temp);
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加加算
		@param[in]	other	加算する相手
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector3& operator+=(const Vector3& other) {
			x += other.x;
			y += other.y;
			z += other.z;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加減算
		@param[in]	other	減算する相手
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector3& operator-=(const Vector3& other) {
			x -= other.x;
			y -= other.y;
			z -= other.z;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加乗算
		@param[in]	val	乗算する値
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector3& operator*=(float val) {
			x *= val;
			y *= val;
			z *= val;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加除算
		@param[in]	val	除算する値
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector3& operator/=(float val) {
			if (val == 0.0f) {
				//0除算
				throw BaseException(
					L"0除算です",
					L"if(val == 0.0f)",
					L"Vector3::operator/=()"
					);
			}
			x /= val;
			y /= val;
			z /= val;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	単項プラス
		@return	演算後のVector3
		*/
		//--------------------------------------------------------------------------------------
		Vector3 operator+ () const {
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	単項マイナス
		@return	演算後のVector3
		*/
		//--------------------------------------------------------------------------------------
		Vector3 operator- () const {
			Vector3 ret = *this;
			ret *= -1.0f;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	加算
		@param[in]	other	加算する相手
		@return	演算後のVector3
		*/
		//--------------------------------------------------------------------------------------
		Vector3 operator+(const Vector3& other)const {
			Vector3 ret = *this;
			ret += other;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	減算
		@param[in]	other	減算する相手
		@return	演算後のVector3
		*/
		//--------------------------------------------------------------------------------------
		Vector3 operator-(const Vector3& other)const {
			Vector3 ret = *this;
			ret -= other;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	乗算
		@param[in]	val	乗算する値
		@return	演算後のVector3
		*/
		//--------------------------------------------------------------------------------------
		Vector3 operator*(float val)const {
			Vector3 ret = *this;
			ret *= val;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	除算
		@param[in]	val	除算する値
		@return	演算後のVector3
		*/
		//--------------------------------------------------------------------------------------
		Vector3 operator/(float val)const {
			if (val == 0.0f) {
				//0除算
				throw BaseException(
					L"0除算です",
					L"if(val == 0.0f)",
					L"Vector3::operator/()"
					);
			}
			Vector3 ret = *this;
			ret /= val;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各値インデックスアクセス
		@param[in]	i	インデックス
		@return	インデックスで指定された値の参照
		*/
		//--------------------------------------------------------------------------------------
		float& operator[](int i) {
			if (i > 2 || i < 0) {
				throw BaseException(
					L"インデックスが範囲外です",
					L"if(i > 2 || i < 0)",
					L"Vector3::operator[]()"
					);
			}
			switch (i) {
			case 0:
				return x;
				break;
			case 1:
				return y;
				break;
			case 2:
				return z;
				break;
			}
			return x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各値インデックスアクセス（const版）
		@param[in]	i	インデックス
		@return	インデックスで指定された値の参照（const版）
		*/
		//--------------------------------------------------------------------------------------
		const float& operator[](int i) const {
			if (i > 2 || i < 0) {
				throw BaseException(
					L"インデックスが範囲外です",
					L"if(i > 2 || i < 0)",
					L"Vector3::operator[]()"
					);
			}
			switch (i) {
			case 0:
				return x;
				break;
			case 1:
				return y;
				break;
			case 2:
				return z;
				break;
			}
			return x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルと等しいかどうかを検証する
		@param[in]	other	相手
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Equal(const Vector3& other)const {
			return XMVector3Equal(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルと等しいかどうかを検証する(==版)
		@param[in]	other	相手
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator==(const Vector3& other)const {
			return Equal(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルと等しいかどうかを検証する。<br />
		それぞれの要素は符号なし整数として扱う。
		@param[in]	other	相手
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool EqualInt(const Vector3& other)const {
			return XMVector3EqualInt(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルより大きいかどうかを検証する
		@param[in]	other	相手
		@return	大きければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Greater(const Vector3& other)const {
			return XMVector3Greater(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルより大きいかどうかを検証する(>版)
		@param[in]	other	相手
		@return	大きければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator>(const Vector3& other)const {
			return Greater(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトル以上の大きさかどうかを検証する
		@param[in]	other	相手
		@return	以上の大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool GreaterOrEqual(const Vector3& other)const {
			return XMVector3GreaterOrEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトル以上の大きさかどうかを検証する(>=版)
		@param[in]	other	相手
		@return	以上の大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator >= (const Vector3& other)const {
			return GreaterOrEqual(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの値のいずれかが正か負の無限大かどうかを検証する。
		@return	値のいずれかが正か負の無限大ならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsInfinite() const {
			return XMVector3IsInfinite(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの値のいずれかが非数（無効値）かどうかを検証する。
		@return	値のいずれかが非数（無効値）ならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsNaN() const {
			return XMVector3IsNaN(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルより小さいかどうかを検証する。
		@param[in]	other	相手
		@return	小さければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Less(const Vector3& other)const {
			return XMVector3Less(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルより小さいかどうかを検証する(<版)。
		@param[in]	other	相手
		@return	小さければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator<(const Vector3& other)const {
			return Less(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトル以下の大きさかどうかを検証する。
		@param[in]	other	相手
		@return	以下の大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool LessOrEqual(const Vector3& other)const {
			return XMVector3LessOrEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトル以下の大きさかどうかを検証する(<=版)。
		@param[in]	other	相手
		@return	以下の大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator <= (const Vector3& other)const {
			return LessOrEqual(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルが近い大きさかどうかを検証する。
		@param[in]	other	相手
		@param[in]	Epsilon	比較する最大許容差
		@return	近い大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool NearEqual(const Vector3& other, float Epsilon)const {
			float temp = Epsilon;
			XMVECTOR VecEp = XMLoadFloat(&temp);
			return XMVector3NearEqual(XMVECTOR(*this), XMVECTOR(other), VecEp);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルと等しくないかどうかを検証する。
		@param[in]	other	相手
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool NotEqual(const Vector3& other)const {
			return XMVector3NotEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルと等しくないかどうかを検証する(!=版)。
		@param[in]	other	相手
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator!=(const Vector3& other)const {
			return NotEqual(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルと等しくないかどうかを検証する。<br />
		それぞれの要素は符号なし整数として扱う。
		@param[in]	other	相手
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool NotEqualInt(const Vector3& other)const {
			return XMVector3NotEqualInt(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	正規化したthisともう一つのつの正規化したベクトルとのラジアン角を計算し返す。<br />
		関数内で正規化はしないので、thisおよびotherはあらかじめ正規化しておく。<br />
		ベクトルのラジアン角計算では、正規化しない分速い。
		@param[in]	other	相手
		@return	ラジアン角
		*/
		//--------------------------------------------------------------------------------------
		float AngleBetweenNormals(const Vector3& other) const {
			return ((Vector3)XMVector3AngleBetweenNormals(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	正規化されたthisと正規化されたもう一つのつのベクトル間のラジアン角を予測して返す。<br />
		関数内で正規化はしないので、thisおよびotherはあらかじめ正規化しておく。<br />
		ベクトルのラジアン角計算では、正規化しない分速い。
		@param[in]	other	相手
		@return	ラジアン角
		*/
		//--------------------------------------------------------------------------------------
		float AngleBetweenNormalsEst(const Vector3& other)const {
			return ((Vector3)XMVector3AngleBetweenNormalsEst(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisともう一つのつのベクトル間のラジアン角を計算する。
		@param[in]	other	相手
		@return	ラジアン角
		*/
		//--------------------------------------------------------------------------------------
		float AngleBetweenVectors(const Vector3& other) const {
			return ((Vector3)XMVector3AngleBetweenVectors(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisを指定した大きさにクランプする。
		@param[in]	LengthMin	長さの最小値
		@param[in]	LengthMax	長さの最大値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void ClampLength(float LengthMin, float LengthMax) {
			*this = XMVector3ClampLength(XMVECTOR(*this), LengthMin, LengthMax);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisを指定した大きさにクランプする。
		@param[in]	LengthMinV	長さの最小値(ベクトル)
		@param[in]	LengthMaxV	長さの最大値(ベクトル)
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void ClampLengthV(const Vector3& LengthMinV, const Vector3& LengthMaxV) {
			*this = XMVector3ClampLengthV(XMVECTOR(*this), XMVECTOR(LengthMinV), XMVECTOR(LengthMaxV));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisとの外積を計算しthisに設定する。
		@param[in]	other	相手
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Cross(const Vector3& other) {
			*this = (Vector3)XMVector3Cross(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisとの内積を返す。
		@param[in]	other	相手
		@return	内積
		*/
		//--------------------------------------------------------------------------------------
		float Dot(const Vector3& other)const {
			return ((Vector3)XMVector3Dot(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisのすべての要素が、設定された境界内にある場合はtrueを返す。
		@param[in]	other	相手
		@return	境界内にある場合はtrue
		*/
		//--------------------------------------------------------------------------------------
		bool InBounds(const Vector3& other) const {
			return XMVector3InBounds(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ベクトルの長さを返す。
		@return	ベクトルの長さ
		*/
		//--------------------------------------------------------------------------------------
		float Length() const {
			return ((Vector3)XMVector3Length(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ベクトルの長さを予想して返す。
		@return	ベクトルの長さの予想
		*/
		//--------------------------------------------------------------------------------------
		float LengthEst() const {
			return ((Vector3)XMVector3LengthEst(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ベクトルの長さの2乗を返す。
		@return	ベクトルの長さの2乗
		*/
		//--------------------------------------------------------------------------------------
		float LengthSq() const {
			return ((Vector3)XMVector3LengthSq(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	正規化する。
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Normalize() {
			*this = XMVector3Normalize(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	正規化の予想値を設定する。
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void NormalizeEst() {
			*this = XMVector3NormalizeEst(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisに垂直なベクトルを設定する。
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Orthogonal() {
			*this = XMVector3Orthogonal(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの長さの逆数を返す。
		@return	thisの長さの逆数
		*/
		//--------------------------------------------------------------------------------------
		float ReciprocalLength()const {
			return ((Vector3)XMVector3ReciprocalLength(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの長さの逆数の予測値を返す。
		@return	thisの長さの逆数の予測値
		*/
		//--------------------------------------------------------------------------------------
		float ReciprocalLengthEst()const {
			return ((Vector3)XMVector3ReciprocalLengthEst(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisに法線ベクトルによって反射させたベクトル(入射ベクトル)を設定する。
		@param[in]	Normal	法線ベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Reflect(const Vector3& Normal) {
			*this = XMVector3Reflect(XMVECTOR(*this), XMVECTOR(Normal));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisに法線ベクトルによって屈折率で反射させたベクトル(入射ベクトル)を設定する。
		@param[in]	Normal	法線ベクトル
		@param[in]	RefractionIndex	屈折率
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Refract(const Vector3& Normal, float RefractionIndex) {
			*this = XMVector3Refract(XMVECTOR(*this), XMVECTOR(Normal), RefractionIndex);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisに法線ベクトルによって屈折率ベクトル（すべての要素が同じ値）で反射させたベクトル(入射ベクトル)を設定する。
		@param[in]	Normal	法線ベクトル
		@param[in]	RefractionIndex	屈折率
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RefractV(const Vector3& Normal, const Vector3& RefractionIndex) {
			*this = XMVector3RefractV(XMVECTOR(*this), XMVECTOR(Normal),
				XMVECTOR(RefractionIndex));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	現在のベクトルと法線ベクトルからスライドするベクトルを得てthisに設定する。
		@param[in]	Normal	法線ベクトル
		@param[in]	RefractionIndex	屈折率
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Slide(const Vector3& Norm) {
			//thisと法線から直行線の長さ（内積で求める）
			float Len = Dot(Norm);
			//その長さに伸ばす
			Vector3 Contact = Norm * Len;
			//スライドする方向は現在のベクトルから引き算
			*this = (*this - Contact);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	スクリーン座標のthisをパラメータによって３D空間に射影する。
		@param[in]	ViewportX	ビューポートの左
		@param[in]	ViewportY	ビューポートの上
		@param[in]	ViewportWidth	ビューポートの幅
		@param[in]	ViewportHeight	ビューポートの高さ
		@param[in]	ViewportMinZ	ビューポートの奥行最小値
		@param[in]	ViewportMaxZ	ビューポートの奥行最大値
		@param[in]	Projection	射影行列
		@param[in]	View	ビュー行列
		@param[in]	World	ワールド行列
		@return	なし（thisに結果を代入する）
		*/
		//--------------------------------------------------------------------------------------
		void Unproject(float ViewportX,float ViewportY,float ViewportWidth,float ViewportHeight,
			float ViewportMinZ,float ViewportMaxZ,
			const XMMATRIX& Projection, const XMMATRIX& View, const XMMATRIX& World
			) {
			*this = XMVector3Unproject(XMVECTOR(*this),
				ViewportX,
				ViewportY,
				ViewportWidth,
				ViewportHeight,
				ViewportMinZ,
				ViewportMaxZ,
				Projection,
				View,
				World
			);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	3D位置のthisを左上原点のスクリーン座標に変換する(結果のzは、NearとFarの範囲外の値は不定になるので注意)
		@param[in]	m	トランスフォームする行列(world,view,projを掛けたもの)
		@param[in]	ViewWidth	ビューポート幅
		@param[in]	ViewHeight	ビューポート高さ
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		inline void WorldToSCreen(const Matrix4X4& m, float ViewWidth, float ViewHeight);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisをmによってトランスフォームされたベクトルを設定する(XMMATRIX版)。
		@param[in]	m	トランスフォームする行列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Transform(const XMMATRIX& m) {
			*this = XMVector3Transform(XMVECTOR(*this), m);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisをmによってトランスフォームされたベクトルを設定する。
		@param[in]	m	トランスフォームする行列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		inline void Transform(const Matrix4X4& m);
	};


	//--------------------------------------------------------------------------------------
	///	Vector4（4Dベクトル）構造体
	//--------------------------------------------------------------------------------------
	struct Vector4 : public XMFLOAT4 {
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		*/
		//--------------------------------------------------------------------------------------
		Vector4() :XMFLOAT4() {
			x = 0;
			y = 0;
			z = 0;
			w = 0;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	v4	XMFLOAT4
		*/
		//--------------------------------------------------------------------------------------
		Vector4(const XMFLOAT4& v4) :XMFLOAT4(v4) {
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	other	XMVECTOR
		*/
		//--------------------------------------------------------------------------------------
		Vector4(const XMVECTOR& other) :XMFLOAT4() {
			XMVECTOR temp = other;
			XMStoreFloat4(this, temp);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	other	XMVECTORF32
		*/
		//--------------------------------------------------------------------------------------
		Vector4(const XMVECTORF32& other) :XMFLOAT4() {
			XMVECTOR temp = other;
			XMStoreFloat4(this, temp);
		}

		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ（値セット）
		@param[in]	x	X値
		@param[in]	y	Y値
		@param[in]	z	Z値
		@param[in]	w	W値
		*/
		//--------------------------------------------------------------------------------------
		Vector4(float x, float y, float z, float w) :
			XMFLOAT4(x, y, z, w) {
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コピーコンストラクタ
		@param[in]	other	コピー元
		*/
		//--------------------------------------------------------------------------------------
		Vector4(const Vector4& other) :XMFLOAT4() {
			x = other.x;
			y = other.y;
			z = other.z;
			w = other.w;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ(Vector3から初期化)。wは0になる
		@param[in]	other	コピー元
		*/
		//--------------------------------------------------------------------------------------
		Vector4(const Vector3& other) :XMFLOAT4() {
			x = other.x;
			y = other.y;
			z = other.z;
			w = 0;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ(Vector3とwから初期化)
		@param[in]	other	コピー元
		@param[in]	ww	W値
		*/
		//--------------------------------------------------------------------------------------
		Vector4(const Vector3& other, float ww) :XMFLOAT4() {
			x = other.x;
			y = other.y;
			z = other.z;
			w = ww;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	x_str	X数値に変換できる文字列
		@param[in]	y_str	Y数値に変換できる文字列
		@param[in]	z_str	Z数値に変換できる文字列
		@param[in]	w_str	W数値に変換できる文字列
		*/
		//--------------------------------------------------------------------------------------
		Vector4(wstring& x_str, wstring& y_str, wstring& z_str, wstring& w_str) {
			x = (float)_wtof(x_str.c_str());
			y = (float)_wtof(y_str.c_str());
			z = (float)_wtof(z_str.c_str());
			w = (float)_wtof(w_str.c_str());
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	XMVECTORへのキャスト（thisをキャストして返す）
		@return	XMVECTOR型の値
		*/
		//--------------------------------------------------------------------------------------
		operator XMVECTOR() const {
			XMFLOAT4 temp = *this;
			XMVECTOR Vec = XMLoadFloat4(&temp);
			return Vec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	メンバ変数への直接代入
		@param[in]	x_str	X数値に変換できる文字列
		@param[in]	y_str	Y数値に変換できる文字列
		@param[in]	z_str	Z数値に変換できる文字列
		@param[in]	w_str	W数値に変換できる文字列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Set(wstring& x_str, wstring& y_str, wstring& z_str, wstring& w_str) {
			x = (float)_wtof(x_str.c_str());
			y = (float)_wtof(y_str.c_str());
			z = (float)_wtof(z_str.c_str());
			w = (float)_wtof(w_str.c_str());
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	メンバ変数への直接代入
		@param[in]	xx	X値
		@param[in]	yy	Y値
		@param[in]	zz	Z値
		@param[in]	ww	W値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Set(float xx, float yy, float zz, float ww) {
			x = xx;
			y = yy;
			z = zz;
			w = ww;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	0初期化
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Zero() {
			x = 0;
			y = 0;
			z = 0;
			w = 0;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector4& operator=(const Vector4& other) {
			//自己代入の抑制
			if (this != &other) {
				x = other.x;
				y = other.y;
				z = other.z;
				w = other.w;
			}
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元(Vector3)。wは0になる
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector4& operator=(const Vector3& other) {
			x = other.x;
			y = other.y;
			z = other.z;
			w = 0;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元(XMVECTOR)
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector4& operator=(const XMVECTOR& other) {
			XMVECTOR temp = other;
			XMStoreFloat4(this, temp);
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加加算
		@param[in]	other	加算する相手
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector4& operator+=(const Vector4& other) {
			x += other.x;
			y += other.y;
			z += other.z;
			w += other.w;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加減算
		@param[in]	other	減算する相手
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector4& operator-=(const Vector4& other) {
			x -= other.x;
			y -= other.y;
			z -= other.z;
			w -= other.w;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加乗算
		@param[in]	val	乗算する値
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector4& operator*=(float val) {
			x *= val;
			y *= val;
			z *= val;
			w *= val;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加除算
		@param[in]	val	除算する値
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		Vector4& operator/=(float val) {
			if (val == 0.0f) {
				//0除算
				throw BaseException(
					L"0除算です",
					L"if(val == 0.0f)",
					L"Vector4::operator/=()"
					);
			}
			x /= val;
			y /= val;
			z /= val;
			w /= val;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	単項プラス
		@return	演算後のVector4
		*/
		//--------------------------------------------------------------------------------------
		Vector4 operator+ () const {
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	単項マイナス
		@return	演算後のVector4
		*/
		//--------------------------------------------------------------------------------------
		Vector4 operator- () const {
			Vector4 ret = *this;
			ret *= -1.0f;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	加算
		@param[in]	other	加算する相手
		@return	演算後のVector4
		*/
		//--------------------------------------------------------------------------------------
		Vector4 operator+(const Vector4& other)const {
			Vector4 ret = *this;
			ret += other;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	減算
		@param[in]	other	減算する相手
		@return	演算後のVector4
		*/
		//--------------------------------------------------------------------------------------
		Vector4 operator-(const Vector4& other)const {
			Vector4 ret = *this;
			ret -= other;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	乗算
		@param[in]	val	乗算する値
		@return	演算後のVector4
		*/
		//--------------------------------------------------------------------------------------
		Vector4 operator*(float val)const {
			Vector4 ret = *this;
			ret *= val;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	除算
		@param[in]	val	除算する値
		@return	演算後のVector4
		*/
		//--------------------------------------------------------------------------------------
		Vector4 operator/(float val)const {
			if (val == 0.0f) {
				//0除算
				throw BaseException(
					L"0除算です",
					L"if(val == 0.0f)",
					L"Vector4::operator/()"
					);
			}
			Vector4 ret = *this;
			ret /= val;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各値インデックスアクセス
		@param[in]	i	インデックス
		@return	インデックスで指定された値の参照
		*/
		//--------------------------------------------------------------------------------------
		float& operator[](int i) {
			if (i > 3 || i < 0) {
				throw BaseException(
					L"インデックスが範囲外です",
					L"if(i > 3 || i < 0)",
					L"Vector4::operator[]()"
					);
			}
			switch (i) {
			case 0:
				return x;
				break;
			case 1:
				return y;
				break;
			case 2:
				return z;
				break;
			case 3:
				return w;
				break;
			}
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各値インデックスアクセス（const版）
		@param[in]	i	インデックス
		@return	インデックスで指定された値の参照（const版）
		*/
		//--------------------------------------------------------------------------------------
		const float& operator[](int i) const {
			if (i > 2 || i < 0) {
				throw BaseException(
					L"インデックスが範囲外です",
					L"if(i > 3 || i < 0)",
					L"Vector4::operator[]()"
					);
			}
			switch (i) {
			case 0:
				return x;
				break;
			case 1:
				return y;
				break;
			case 2:
				return z;
				break;
			case 3:
				return w;
				break;
			}
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルと等しいかどうかを検証する
		@param[in]	other	相手
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Equal(const Vector4& other)const {
			return XMVector4Equal(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルと等しいかどうかを検証する(==版)
		@param[in]	other	相手
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator==(const Vector4& other)const {
			return Equal(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルと等しいかどうかを検証する。<br />
		それぞれの要素は符号なし整数として扱う。
		@param[in]	other	相手
		@return	等しければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool EqualInt(const Vector4& other)const {
			return XMVector4EqualInt(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルより大きいかどうかを検証する
		@param[in]	other	相手
		@return	大きければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Greater(const Vector4& other)const {
			return XMVector4Greater(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトルより大きいかどうかを検証する(>版)
		@param[in]	other	相手
		@return	大きければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator>(const Vector4& other)const {
			return Greater(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトル以上の大きさかどうかを検証する
		@param[in]	other	相手
		@return	以上の大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool GreaterOrEqual(const Vector4& other)const {
			return XMVector4GreaterOrEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう1つのベクトル以上の大きさかどうかを検証する(>=版)
		@param[in]	other	相手
		@return	以上の大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator >= (const Vector4& other)const {
			return GreaterOrEqual(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの値のいずれかが正か負の無限大かどうかを検証する。
		@return	値のいずれかが正か負の無限大ならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsInfinite() const {
			return XMVector4IsInfinite(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの値のいずれかが非数（無効値）かどうかを検証する。
		@return	値のいずれかが非数（無効値）ならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsNaN() const {
			return XMVector4IsNaN(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルより小さいかどうかを検証する。
		@param[in]	other	相手
		@return	小さければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool Less(const Vector4& other)const {
			return XMVector4Less(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルより小さいかどうかを検証する(<版)。
		@param[in]	other	相手
		@return	小さければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator<(const Vector4& other)const {
			return Less(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトル以下の大きさかどうかを検証する。
		@param[in]	other	相手
		@return	以下の大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool LessOrEqual(const Vector4& other)const {
			return XMVector4LessOrEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトル以下の大きさかどうかを検証する(<=版)。
		@param[in]	other	相手
		@return	以下の大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator <= (const Vector4& other)const {
			return LessOrEqual(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルが近い大きさかどうかを検証する。
		@param[in]	other	相手
		@param[in]	Epsilon	比較する最大許容差
		@return	近い大きさならばtrue
		*/
		//--------------------------------------------------------------------------------------
		bool NearEqual(const Vector4& other, float Epsilon)const {
			float temp = Epsilon;
			XMVECTOR VecEp = XMLoadFloat(&temp);
			return XMVector4NearEqual(XMVECTOR(*this), XMVECTOR(other), VecEp);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルと等しくないかどうかを検証する。
		@param[in]	other	相手
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool NotEqual(const Vector4& other)const {
			return XMVector4NotEqual(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルと等しくないかどうかを検証する(!=版)。
		@param[in]	other	相手
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool operator!=(const Vector4& other)const {
			return NotEqual(other);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisがもう一つのベクトルと等しくないかどうかを検証する。<br />
		それぞれの要素は符号なし整数として扱う。
		@param[in]	other	相手
		@return	等しくなければtrue
		*/
		//--------------------------------------------------------------------------------------
		bool NotEqualInt(const Vector4& other)const {
			return XMVector4NotEqualInt(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	正規化したthisともう一つのつの正規化したベクトルとのラジアン角を計算し返す。<br />
		関数内で正規化はしないので、thisおよびotherはあらかじめ正規化しておく。<br />
		ベクトルのラジアン角計算では、正規化しない分速い。
		@param[in]	other	相手
		@return	ラジアン角
		*/
		//--------------------------------------------------------------------------------------
		float AngleBetweenNormals(const Vector4& other)const {
			return ((Vector4)XMVector4AngleBetweenNormals(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	正規化されたthisと正規化されたもう一つのつのベクトル間のラジアン角を予測して返す。<br />
		関数内で正規化はしないので、thisおよびotherはあらかじめ正規化しておく。<br />
		ベクトルのラジアン角計算では、正規化しない分速い。
		@param[in]	other	相手
		@return	ラジアン角
		*/
		//--------------------------------------------------------------------------------------
		float AngleBetweenNormalsEst(const Vector4& other)const {
			return ((Vector4)XMVector4AngleBetweenNormalsEst(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisともう一つのつのベクトル間のラジアン角を計算する。
		@param[in]	other	相手
		@return	ラジアン角
		*/
		//--------------------------------------------------------------------------------------
		float AngleBetweenVectors(const Vector4& other)const {
			return ((Vector4)XMVector4AngleBetweenVectors(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisを指定した大きさにクランプする。
		@param[in]	LengthMin	長さの最小値
		@param[in]	LengthMax	長さの最大値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void ClampLength(float LengthMin, float LengthMax) {
			*this = XMVector4ClampLength(XMVECTOR(*this), LengthMin, LengthMax);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisを指定した大きさにクランプする。
		@param[in]	LengthMinV	長さの最小値(ベクトル)
		@param[in]	LengthMaxV	長さの最大値(ベクトル)
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void ClampLengthV(const Vector4& LengthMinV, const Vector4& LengthMaxV) {
			*this = XMVector4ClampLengthV(XMVECTOR(*this), XMVECTOR(LengthMinV), XMVECTOR(LengthMaxV));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisとの外積を計算しthisに設定する。
		@param[in]	other1	相手1
		@param[in]	other2	相手2
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Cross(const Vector4& other1, const Vector4& other2) {
			*this = XMVector4Cross(XMVECTOR(*this), XMVECTOR(other1), XMVECTOR(other2));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisとの内積を返す。
		@param[in]	other	相手
		@return	内積
		*/
		//--------------------------------------------------------------------------------------
		float Dot(const Vector4& other)const {
			return ((Vector4)XMVector4Dot(XMVECTOR(*this), XMVECTOR(other))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisのすべての要素が、設定された境界内にある場合はtrueを返す。
		@param[in]	other	相手
		@return	境界内にある場合はtrue
		*/
		//--------------------------------------------------------------------------------------
		bool InBounds(const Vector4& other) const {
			return XMVector4InBounds(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ベクトルの長さを返す。
		@return	ベクトルの長さ
		*/
		//--------------------------------------------------------------------------------------
		float Length() const {
			return ((Vector4)XMVector4Length(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ベクトルの長さを予想して返す。
		@return	ベクトルの長さの予想
		*/
		//--------------------------------------------------------------------------------------
		float LengthEst() const {
			return ((Vector4)XMVector4LengthEst(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ベクトルの長さの2乗を返す。
		@return	ベクトルの長さの2乗
		*/
		//--------------------------------------------------------------------------------------
		float LengthSq() const {
			return ((Vector4)XMVector4LengthSq(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	正規化する。
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Normalize() {
			*this = XMVector4Normalize(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	正規化の予想値を設定する。
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void NormalizeEst() {
			*this = XMVector4NormalizeEst(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisに垂直なベクトルを設定する。
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Orthogonal() {
			*this = XMVector4Orthogonal(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの長さの逆数を返す。
		@return	thisの長さの逆数
		*/
		//--------------------------------------------------------------------------------------
		float ReciprocalLength()const {
			return ((Vector4)XMVector4ReciprocalLength(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの長さの逆数の予測値を返す。
		@return	thisの長さの逆数の予測値
		*/
		//--------------------------------------------------------------------------------------
		float ReciprocalLengthEst()const {
			return ((Vector4)XMVector4ReciprocalLengthEst(XMVECTOR(*this))).x;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisに法線ベクトルによって反射させたベクトル(入射ベクトル)を設定する。
		@param[in]	Normal	法線ベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Reflect(const Vector4& Normal) {
			*this = XMVector4Reflect(XMVECTOR(*this), XMVECTOR(Normal));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisに法線ベクトルによって屈折率で反射させたベクトル(入射ベクトル)を設定する。
		@param[in]	Normal	法線ベクトル
		@param[in]	RefractionIndex	屈折率
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Refract(const Vector4& Normal, float RefractionIndex) {
			*this = XMVector4Refract(XMVECTOR(*this), XMVECTOR(Normal), RefractionIndex);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisに法線ベクトルによって屈折率ベクトル（すべての要素が同じ値）で反射させたベクトル(入射ベクトル)を設定する。
		@param[in]	Normal	法線ベクトル
		@param[in]	RefractionIndex	屈折率
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void RefractV(const Vector4& Normal, const Vector4& RefractionIndex) {
			*this = XMVector4RefractV(XMVECTOR(*this), XMVECTOR(Normal),
				XMVECTOR(RefractionIndex));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisをmによってトランスフォームされたベクトルを設定する(XMMATRIX版)。
		@param[in]	m	トランスフォームする行列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Transform(const XMMATRIX& m) {
			*this = XMVector4Transform(XMVECTOR(*this), m);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisをmによってトランスフォームされたベクトルを設定する。
		@param[in]	m	トランスフォームする行列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		inline void Transform(const Matrix4X4& m);
	};

	//--------------------------------------------------------------------------------------
	///	1次元XMVECTORのラッピング構造体
	//--------------------------------------------------------------------------------------
	struct XMVector : public XMFLOAT4 {
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		*/
		//--------------------------------------------------------------------------------------
		XMVector() :XMFLOAT4() {
			x = 0;
			y = 0;
			z = 0;
			w = 0;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	v4	XMFLOAT4
		*/
		//--------------------------------------------------------------------------------------
		XMVector(const XMFLOAT4& v4) :XMFLOAT4(v4) {
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	other	XMVECTOR
		*/
		//--------------------------------------------------------------------------------------
		XMVector(const XMVECTOR& other) :XMFLOAT4() {
			XMVECTOR temp = other;
			XMStoreFloat4(this, temp);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ（値セット）
		@param[in]	x	X値
		@param[in]	y	Y値
		@param[in]	z	Z値
		@param[in]	w	W値
		*/
		//--------------------------------------------------------------------------------------
		XMVector(float x, float y, float z, float w) :
			XMFLOAT4(x, y, z, w) {
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ（値セット）
		@param[in]	all	all値
		*/
		//--------------------------------------------------------------------------------------
		XMVector(float all) :
			XMFLOAT4(all, all, all, all) {
		}

		//--------------------------------------------------------------------------------------
		/*!
		@brief	コピーコンストラクタ
		@param[in]	other	コピー元
		*/
		//--------------------------------------------------------------------------------------
		XMVector(const XMVector& other) :XMFLOAT4() {
			x = other.x;
			y = other.y;
			z = other.z;
			w = other.w;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ(Vector4から初期化)
		@param[in]	other	コピー元
		*/
		//--------------------------------------------------------------------------------------
		XMVector(const Vector4& other) :XMFLOAT4() {
			x = other.x;
			y = other.y;
			z = other.z;
			w = other.w;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ(Vector3から初期化)。wは0になる
		@param[in]	other	コピー元
		*/
		//--------------------------------------------------------------------------------------
		XMVector(const Vector3& other) :XMFLOAT4() {
			x = other.x;
			y = other.y;
			z = other.z;
			w = 0;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ(Vector3とwから初期化)
		@param[in]	other	コピー元
		@param[in]	ww	W値
		*/
		//--------------------------------------------------------------------------------------
		XMVector(const Vector3& other, float ww) :XMFLOAT4() {
			x = other.x;
			y = other.y;
			z = other.z;
			w = ww;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	x_str	X数値に変換できる文字列
		@param[in]	y_str	Y数値に変換できる文字列
		@param[in]	z_str	Z数値に変換できる文字列
		@param[in]	w_str	W数値に変換できる文字列
		*/
		//--------------------------------------------------------------------------------------
		XMVector(wstring& x_str, wstring& y_str, wstring& z_str, wstring& w_str) {
			x = (float)_wtof(x_str.c_str());
			y = (float)_wtof(y_str.c_str());
			z = (float)_wtof(z_str.c_str());
			w = (float)_wtof(w_str.c_str());
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	XMVECTORへのキャスト（thisをキャストして返す）
		@return	XMVECTOR型の値
		*/
		//--------------------------------------------------------------------------------------
		operator XMVECTOR() const {
			XMFLOAT4 temp = *this;
			XMVECTOR Vec = XMLoadFloat4(&temp);
			return Vec;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	メンバ変数への直接代入
		@param[in]	x_str	X数値に変換できる文字列
		@param[in]	y_str	Y数値に変換できる文字列
		@param[in]	z_str	Z数値に変換できる文字列
		@param[in]	w_str	W数値に変換できる文字列
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Set(wstring& x_str, wstring& y_str, wstring& z_str, wstring& w_str) {
			x = (float)_wtof(x_str.c_str());
			y = (float)_wtof(y_str.c_str());
			z = (float)_wtof(z_str.c_str());
			w = (float)_wtof(w_str.c_str());
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	メンバ変数への直接代入
		@param[in]	xx	X値
		@param[in]	yy	Y値
		@param[in]	zz	Z値
		@param[in]	ww	W値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Set(float xx, float yy, float zz, float ww) {
			x = xx;
			y = yy;
			z = zz;
			w = ww;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	0初期化
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Zero() {
			x = 0;
			y = 0;
			z = 0;
			w = 0;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		XMVector& operator=(const XMVector& other) {
			//自己代入の抑制
			if (this != &other) {
				x = other.x;
				y = other.y;
				z = other.z;
				w = other.w;
			}
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元(Vector3)。wは0になる
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		XMVector& operator=(const Vector3& other) {
			x = other.x;
			y = other.y;
			z = other.z;
			w = 0;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	代入
		@param[in]	other	コピー元(XMVECTOR)
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		XMVector& operator=(const XMVECTOR& other) {
			XMVECTOR temp = other;
			XMStoreFloat4(this, temp);
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加加算
		@param[in]	other	加算する相手
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		XMVector& operator+=(const XMVector& other) {
			x += other.x;
			y += other.y;
			z += other.z;
			w += other.w;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加減算
		@param[in]	other	減算する相手
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		XMVector& operator-=(const XMVector& other) {
			x -= other.x;
			y -= other.y;
			z -= other.z;
			w -= other.w;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加乗算
		@param[in]	val	乗算する値
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		XMVector& operator*=(float val) {
			x *= val;
			y *= val;
			z *= val;
			w *= val;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	追加除算
		@param[in]	val	除算する値
		@return	演算後の*thisの参照
		*/
		//--------------------------------------------------------------------------------------
		XMVector& operator/=(float val) {
			if (val == 0.0f) {
				//0除算
				throw BaseException(
					L"0除算です",
					L"if(val == 0.0f)",
					L"XMVector::operator/=()"
					);
			}
			x /= val;
			y /= val;
			z /= val;
			w /= val;
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	単項プラス
		@return	演算後のVector4
		*/
		//--------------------------------------------------------------------------------------
		XMVector operator+ () const {
			return *this;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	単項マイナス
		@return	演算後のVector4
		*/
		//--------------------------------------------------------------------------------------
		XMVector operator- () const {
			XMVector ret = *this;
			ret *= -1.0f;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	加算
		@param[in]	other	加算する相手
		@return	演算後のXMVector
		*/
		//--------------------------------------------------------------------------------------
		XMVector operator+(const XMVector& other)const {
			XMVector ret = *this;
			ret += other;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	減算
		@param[in]	other	減算する相手
		@return	演算後のXMVector
		*/
		//--------------------------------------------------------------------------------------
		XMVector operator-(const XMVector& other)const {
			XMVector ret = *this;
			ret -= other;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	乗算
		@param[in]	val	乗算する値
		@return	演算後のXMVector
		*/
		//--------------------------------------------------------------------------------------
		XMVector operator*(float val)const {
			XMVector ret = *this;
			ret *= val;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	除算
		@param[in]	val	除算する値
		@return	演算後のVector4
		*/
		//--------------------------------------------------------------------------------------
		XMVector operator/(float val)const {
			if (val == 0.0f) {
				//0除算
				throw BaseException(
					L"0除算です",
					L"if(val == 0.0f)",
					L"XMVector::operator/()"
					);
			}
			XMVector ret = *this;
			ret /= val;
			return ret;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各値インデックスアクセス
		@param[in]	i	インデックス
		@return	インデックスで指定された値の参照
		*/
		//--------------------------------------------------------------------------------------
		float& operator[](size_t i) {
			if (i > 3) {
				throw BaseException(
					L"インデックスが範囲外です",
					L"if(i > 3)",
					L"XMVector::operator[]()"
					);
			}
			switch (i) {
			case 0:
				return x;
				break;
			case 1:
				return y;
				break;
			case 2:
				return z;
				break;
			case 3:
				return w;
				break;
			}
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各値インデックスアクセス（const版）
		@param[in]	i	インデックス
		@return	インデックスで指定された値の参照（const版）
		*/
		//--------------------------------------------------------------------------------------
		float operator[](size_t i) const {
			if (i > 3) {
				throw BaseException(
					L"インデックスが範囲外です",
					L"if(i > 3)",
					L"XMVector::operator[]()"
					);
			}
			switch (i) {
			case 0:
				return x;
				break;
			case 1:
				return y;
				break;
			case 2:
				return z;
				break;
			case 3:
				return w;
				break;
			}
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各要素を絶対値に設定する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Abs() {
			*this = XMVectorAbs(XMVECTOR(*this));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各要素にotherの各要素を加算する
		@param[in]	other	相手
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Add(const XMVector& other) {
			*this = XMVectorAdd(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各要素にotherの各要素角度加算する。thisとotherは、-XM_PI以上XM_PI未満である必要がある
		@param[in]	other	相手
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void AddAngles(const XMVector& other) {
			*this = XMVectorAddAngles(XMVECTOR(*this), XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各要素の上限を計算し、設定する
		@param[in]	other	相手
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Ceiling(const XMVector& other) {
			*this = XMVectorCeiling(XMVECTOR(other));
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	各要素の指定された最大値と最小値の範囲にクランプする
		@param[in]	min	最小値
		@param[in]	max	最大値
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Clamp(const XMVector& min, const XMVector& max) {
			*this = XMVectorClamp(XMVECTOR(*this), XMVECTOR(min), XMVECTOR(max));
		}


		//--------------------------------------------------------------------------------------
		/*!
		@brief	thisの平方根を計算し、設定する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Sqrt() {
			*this = XMVectorSqrt(XMVECTOR(*this));
		}

		//--------------------------------------------------------------------------------------
		/*!
		@brief	累乗を計算し、設定する
		@param[in]	other	相手（何乗か）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void Pow(const XMVector& other) {
			*this = XMVectorPow(XMVECTOR(*this),XMVECTOR(other));
		}


	};
}
//end of namespace basecross.
